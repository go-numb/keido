+++
title = "📝Google Cloud Firestore"
tags = ["WIKI"]
draft = false
+++

Goolge Cloudの提供するサーバレスなNoSQLサービス.

Google Cloud からFirestoreの機能を切り出したのがFirebase Firestoreなのでここでは同一のもとして述べる.

-   [🔗Cloud Firestore  |  Firebase Documentation](https://firebase.google.com/docs/firestore/)

refs: [🏷NoSQL]({{< relref "20220311163333.md" >}}) [🏷Google Cloud]({{< relref "20220311153749.md" >}})


## Firestoreの特徴 {#firestoreの特徴}

データベースというよりは、検索可能なデータ置き場.
複雑なデータ処理が要求されるようなアプリには余り向いてない.


## Firestoreの基本概念: データモデル(DataModel) {#firestoreの基本概念-データモデル--datamodel}

ref: [Cloud Firestore データモデル  |  Firebase Documentation](https://firebase.google.com/docs/firestore/data-model?hl=ja)

ドキュメントはストレージの単位. コレクションはドキュメントのコンテナ.


### クエリ(query) {#クエリ--query}

Firestoreに送信するリクエストのこと.


### リファレンス(Reference) {#リファレンス--reference}

リファレンス(Reference)はデータベース内の場所を参照するだけのオブジェクト.
リファレンスを作成してもネットワーク操作は実行されない.

-   DocumentReference
-   CollectionReference

Referenceに対して.getをするとSnapshotが手に入る.


### スナップショット(Snapshot) {#スナップショット--snapshot}

スナップショット(Snapshot)はデータのオブジェクト.
.getData()によってデータ本体(JSON)を取り出す.


### JavaのFirestoreに関わるクラスとメソッド {#javaのfirestoreに関わるクラスとメソッド}

複雑すぎるな...

-   &lt;Firestore&gt;
    -   .collection(&lt;String&gt;)
        -   &lt;CollectionReference&gt;
            -   .listDocuments()
                -   list of &lt;DocumentReference&gt;
            -   .getAll()
                -   list of &lt;List&lt;DocumentSnapshot&gt;&gt;
            -   .document(&lt;String&gt;)
                -   &lt;DocumentReference&gt;
            -   .get() -&gt; ここから以下は listDocuments()と同等.
                -   &lt;SettableApiFuture&gt;
                    -   (futureから取り出す) clojure deref/@
                        -   &lt;QuerySnapshort&gt;
                            -   getDocuments()
                                -   list of &lt;DocumentReferenece&gt;

    -   .document(&lt;String&gt;)
        -   &lt;DocumentReference&gt;
            -   .get()
                -   &lt;ListenableFutureToApiFuture&gt;
                    -   (futureから取り出す) clojure deref/@
                        -   &lt;DocumentSnapshot&gt;
                            -   .getData()
                                -   java.HashMap
                            -   .getId()

通信の観点で整理.

Referenceは通信前, getによって通信がバックグラウンドで開始する.

Futureは通信をバックグラウンドで実行のため通信中.
通信結果はこの時点ではわからない.
exists()などで結果を確認しないといけない.

Snapshotは通信後. データはkey-valueのペアのため,
getId/getDataでそれぞれアクセス.


## Firestore: データの関係(Relationship) {#firestore-データの関係--relationship}


### Firestore キー(or ID) {#firestore-キー--or-id}

あるドキュメントの参照として別のドキュメントを示すkeyやidをStringで保持する.

これが普通の発想でありFirestoreというドメインに特化していない.
残りの2つはFirestoreの独自機能なので便利である分注意も必要.


### Firestore サブコレクション(Subcollection) {#firestore-サブコレクション--subcollection}

ふたつのコレクションが親子関係にあり,
子のコレクションは1つの親にのみ依存するならばサブコレクションをつかうことでツリー構造に管理できる.


### Firestore 参照型(reference type) {#firestore-参照型--reference-type}

他のコレクションやドキュメントへの参照を保持することができる.
SQLにおける外部キーの概念.

参照型をつかうとidよりも格納されているものが明確できる.


### 💡考察: データはそのままデータとして扱いたい {#考察-データはそのままデータとして扱いたい}

ClojureのData as dataのconceptからすると
jsonをそのまま格納したほうがsimpleなので,
ドメインに依存する参照型はあまり積極的に使う理由はないな.
マップの中のマップは見かけるのでサブコレクションは形容できる.

セキュリティルールも考慮に入れる必要あり.

設計哲学的に迷ったらよりシンプルな方法を採用したい.


## Firestore: DB設計のベストプラクティス {#firestore-db設計のベストプラクティス}

FirestoreのDB設計は正解はないが指針やベストプラクティスがある.

-   更新頻度によってデータを分ける.
-   セキュリティによってデータを分ける.
-   速度を優先するなら非正規化, そうでなければ(保守を優先するなら)正規化.
-   データの結合はクライアントで行う([Application Side Join]({{< relref "20220311163333.md#nosqlのdb設計" >}}))

Google Firebase公式のデータ構造選択の指針

[データ構造の選択  |  Firebase Documentation](https://firebase.google.com/docs/firestore/manage-data/structure-data?hl=ja)

-   ドキュメント内のネストデータ
    -   時間経過とともに変化しないものならこれがいい, read only.
-   サブコレクション
    -   時間経過とともにデータが大きくなる場合はこれ.
    -   サブコレクションはかんたんに削除できない(自力で削除).
-   ルートレベルのコレクション
    -   全てルートにコレクションを配置, サブコレクションは使わない.

FirestoreはNoSQLの仲間なのでNoSQLのベストプラクティスが参考になる.

[NoSQLデータモデリング技法](https://gist.github.com/matope/2396234)


## Firestore: 命名規約 {#firestore-命名規約}

Firestoreの命名規約に関する明確なドキュメントは見当たらなかった.
おそらく開発言語の命名規約に従うのがいい.

複数言語で開発する場合は, Cloud APIsのドキュメントに従うことにする.
これはおそらくJavaの慣習.

[命名規則  |  Cloud APIs  |  Google Cloud](https://cloud.google.com/apis/design/naming_convention)

-   コレクション/ドキュメント
    -   複数形の単語 or 複合語
    -   アメリカ英語のスペルとセマンティクス(not イギリス英語).
    -   ex. events, children, deletedEvents
-   フィールド名
    -   snake_case(lower_case_underscore_separated_names)推奨.
    -   前置詞を含めないことが推奨
        -   reason_for_error よりも error_reason.
        -   cpu_usage_at_time_of_failure よりも failer_time_cpu_usage.
    -   後置形容詞を使用しないことも推奨
        -   items_collected よりも collected_items
        -   objects_importedよりも imported_objects
-   タイムスタンプ
    -   タイムゾーンやカレンダーに関わらずgoogle.protobuf.Timestampが推奨.
    -   start_time, end_timeのように, 末尾にtimeをつけることが推奨.
    -   google.type.Dateと_dateのprefix推奨.
-   ソフトウェア開発での慣習的略語があればそれを推奨.
    -   config/id/spec/stas...

[🏷命名規約]({{< relref "20220308155618.md" >}})
