+++
title = "📝Clojure Logics"
lastmod = 2022-09-11T22:03:12+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Core Languages]({{< relref "20220112142936.md" >}})
-   refs.
    -   [📝Clojure フロー制御]({{< relref "20220116083656.md" >}})
    -   [📝Clojure フォーム]({{< relref "20220505210059.md" >}})
    -   [📝nilのハンドリングまとめ]({{< relref "20220302101805.md#0fbf4219-4020-4829-ae01-f057df406c59" >}})

Clojureの論理制御のシンタックスまとめ.

ほかのパラダイムだと条件式のロジックで使われるandやorは, Lispの世界だと式を順次評価していくような使い方なので, シーケンス制御と論理制御を合わせてこのメモで扱う(シーケンスとはフロー制御の中でのな直線的な処理の意でつかっている).


## Clojure真偽値(true/false) {#25b66742-92cd-4892-b950-6eecc8474ae5}

[📝Clojure フォーム]({{< relref "20220505210059.md" >}})の一つとしての論理値, 真偽値(true/false)


### 💡Clojureの世界における真と偽 {#2830f9}

Clojureではfalseとnilとが偽であり. ほかは真である.

-   空リスト[]は偽ではない. (cf. Common Lisp)
-   0は偽ではない (cf. C言語).


## Clojure 条件式 {#fe1750}

フォームを評価する基本的なものを列挙.

-   true?
-   false?
-   nil?
    -   not-nil?はないが, some?でnil判定はできる.
-   not
-   =
-   not=: not equal
-   empty?
-   seq


### シーケンスに対する述語 {#f26278}

第一引数に条件(predicate), 末尾にCollectionを取る.

> (xxx pred coll)

これらはfilter関数とあわせて用いられる.

-   every?
-   not-any?
-   not-every?

これはcollのみ ([x])

-   any?


### some {#03d59e}

someはシーケンスのいづれかの値が条件を満たすかどうかを判定する.

(some pred coll)

戻り値に注意!

述語がtrueを返したら直ちにその値を返す. 全てがfalseならnilを返す.


## Clojure: 副作用のあるシーケンス制御(do/doto) {#0c94d6da-7462-4a91-9159-8c265b672394}

いわゆるdoなんちゃら.

-   do
-   doto
-   dorun(cf. doall)


### do {#d4579b}

**do** は複数のフォームを手続き的に評価するときに利用する. いちおうなくてもいいけどClojureは関数型パラダイムなので副作用を伴う一連の手続きはdoを書いたほうが親切.

doの戻り値は最後の評価.


### doto {#7e03e1}

**doto** は 第一引数に対して手続き的な操作を行うときに利用する. 主な利用シーンはDBに対してのコマンド発行.

Javaのライブラリをつかうときによくつかう. とくにJavaの[メソッドチェーン]({{< relref "20220117174424.md#57c40755-2b20-4835-af5c-e91cdda3c4c5" >}})が使われている場合. hoge.foo().bar().zzz().


### dorun/doall {#dea9ae38-ea8d-476e-a04e-0149bf17766a}

**dorun**, **doall** は遅延シーケンスのコンテキストで登場する. どちらも遅延評価されたものを強制的に評価して実行する.

そのさい, dorunは単に評価してその結果を考慮せずにnilを返す, つまり副作用があろうが関係ない. 一方doallは遅延シーケンスを評価した結果をシーケンスにして返す.

cf. [Clojure: 遅延評価/遅延シーケンス]({{< relref "20220116094551.md#4f51982f-85bd-4e92-a85e-12cf66360653" >}})


## Clojure: 繰り返しのシーケンス制御(dotimes/doseq/for) {#f049f947-ed63-4ae2-b073-5c9150cf60b3}

繰り返しのシーケンス制御について.

-   dotimes
    -   式n回評価, nilを返す.
-   doseq
    -   シーケンスに対して順列に繰り返す.
    -   遅延シーケンスは評価を強制.
    -   nilを返す.
    -   複数のシーケンスに対しはforEachのように振る舞う.
-   for
    -   [リスト内包表記 | List Comprehensions]({{< relref "20220305080412.md#86a37ede-8969-458b-945d-a72214ec1c1a" >}}).
    -   ジェネレータ関数.


### 💡Clojureの繰り返し: map vs doseq(for) {#cb2449fb-2bed-4b5d-8633-5ce00723f7fa}

どちらもシーケンスに対する処理を実施する.

副作用があるときにdoseq(for)を利用する, そうでないときにmapを利用する.

なるべく副作用がないようにプログラミングを構築するというClojureの考えとしてはdoseqよりもmapのほうが登場回数が多い.

mapは関数をすぐには適用せずに遅延シーケンスを構築する. 実際に中の値の評価をするにはdoall, intoなどの方法が必要.

```clojure
(doall (map coll))
(into [] (map coll))
(into-array (map coll))
```

---

リスト内包表記(for)はmap/filterよりもhuman-readableという利点はある. 以下は同じである.

```clojure
(for [number [1 2 3]] (* number 2))
(map #(* % 2) [1 2 3])
```

シンプルな変換処理を有限なリストに適用するならばmap/filterよりもみやすいかもしれない(Pythonではmap/filterよりもリスト内包表記がよくつかわれる).

ひとつのシーケンスに複数の変化を施すならば遅延シーケンスを扱うmapに利点がある. 複数のシーケンスを順番に従って取り出して扱うならばforのほうが読みやすい(cf. mapcat, juxt).

---

-   refs.
    -   [Clojure Map(clojure.core.map)]({{< relref "20220116080205.md#30a935ff-4448-43a2-8ec7-8c37e18b6ca5" >}})
    -   [Map vs For - Google Group](https://groups.google.com/g/clojure/c/UH3VynMwPic)
    -   [List Comprehension · Practicalli Clojure](https://practical.li/clojure/thinking-functionally/list-comprehension.html)


## Clojure and/or Macros {#74ce46df-08ac-453d-a194-b0ff7817511a}


### 💡andとorを条件分岐につかう {#420b5cde-0746-4e0d-879b-0c6697b473c3}

orに与えられた式で真になるものが見つかったら残りを評価せずに真を返す(cf. [yogthos/config](https://github.com/yogthos/config/blob/81750c8fdb946050a8074f14ab03c8b226536b1a/src/config/core.clj#L57)).

andに与えられた式で偽になるものが見つからない限り残りを評価する.

ref: [📚Land of Lisp]({{< relref "20211113235959.md" >}}) p47に書いてあった方法.


### 💡LISPの世界のand/orはフロー制御の評価器 {#405a42c1-b9b5-4e84-bf8c-d151623921d7}

Clojure(というよりもLisp)のandとorはほかのパラダイムとは少し違うことに注意. and と or は条件式(pred)を結合するのに使う. しかし, 真偽値を返すだけではなく, 値そのものが返る.

これは[副作用に関わるClojureの述語(do/doto)](#0c94d6da-7462-4a91-9159-8c265b672394)に近い意味合いなのだ. Lispの世界において, and/or真偽を返すだけのものではない. 順番に式を評価しながら先に進んでいくようなフロー制御に使えるような評価器なのだ.

orははじめて真になった値を返してその後の評価を打ち切る. andは真になリ続ける限り次を評価して, falseになったら評価をやめる. これは面白い性質であり, これを用いていろんな制御が書ける. and, orを使いこなすとコードを短くすることができる(ref. [andとorを条件分岐につかう](#420b5cde-0746-4e0d-879b-0c6697b473c3)).

ref. [(clj 3) Clojure's 'and' and 'or' are weird (but not really) | Joep Schuurkes](https://smallsheds.garden/blog/clojure/2020/clj3-and-or-being-weird/)


## Clojure: Threading Macros {#508f51c6-37cb-4b61-9bce-91075f1f067e}

-   スレッディングマクロ.
-   基本的には **->** と **->>** をつかう.
-   入れ子構造の関数呼び出しを逐次処理な呼び出しに変える.

refs:

-   [clojure.org - Threading Macros Guide](https://clojure.org/guides/threading_macros)
-   [スレッドマクロを整理する - 紙箱](https://boxofpapers.hatenablog.com/entry/threading_macros)


### thread-first (->) と thread-last (->>) {#8df000}

-> も ->>も1つ目のフォームを初期値にして2つ目のフォームから逐次適用していく.

->はフォームの第一引数に引数が入る. 一方, ->>は最終引数に引数が入る.

->> 利用するケースは第一引数に高階関数を受取り末尾にリストを受け取るような関数である.(map, filter, reduce...)

see also: [💡Clojureデータ構造の操作関数の分類]({{< relref "20220116080205.md#582983e0-0ed8-419e-aa14-c9b227ad42f9" >}})


### as-> clojure thread-firstとthead-lastを混在させる {#f8bc06}

thread-as or as->をつかうことで, 混在させられる.

```clojure
(-> [10 11]
    (conj 12)
    (as-> xs (map - xs [3 2 1]))
    (reverse))
; (11 9 7)
```


### cond-> 条件つきスレッドマクロ {#edc8041c-a7eb-4b51-8433-f8b1038b3ffc}

cond->は初期値と(条件, 処理)のリストを受ける. 条件が真のときのみ処理はされる.

```clojure
(cond-> (初期値)
  (条件) (処理)
  (条件) (処理)
  (条件) (処理))
```

もし存在すれば(if-exists)そのデータを初期値に加えるようなときにつかう. 初期値がcollectionで, もしparamが存在すればそれをcollectionにaddやassocやconjみたいなケースでよく見かける.

[条件付きMap操作: assoc-if/update-if 追加する値がnilでなければ操作]({{< relref "20220302101805.md#659c997d-8c8e-4837-a8b3-a60cc77082c4" >}})


### some->/some->> : 副作用のある呼び出しを中断 {#83a26d9b-05ee-4e0f-b052-49f701755297}

ref. [some-> - Threading Macros Guide](https://clojure.org/guides/threading_macros#_some_some_and_cond)

Threadingマクロの途中で副作用のあるJavaの関数(往々にして戻り値がない, つまりnullを返す可能性がある)を呼び出す時, 途中結果がnullならばその後の処理を打ち切る用途としてsome->というスレッディングマクロがある.


### Emacs clojure-mode: M-x clojure-thread {#f4cff6}

Emacs clojure-modeの threadingリファクタリングサポート.

ref: <https://github.com/clojure-emacs/clojure-mode/#refactoring-support>

-   clojure-unwind/clojure-unwind-all:
    -   threading expressionを解く.
-   clojure-thread-first-all: -> へ変換.
-   clojure-thread-last-all: ->> へ変換.

threading macrosを理解するには, ->> の内側で M-x clojure-unwind-allを叩くとスレッディングマクロを使わない場合に変換される. もとに戻すには, M-x clojure-thread-last-all.


### スレッディングマクロの途中で中身をのぞく {#230cf6}

ref. [Clojureで仕事をはじめて１年経った - さめたコーヒー](https://www.kbaba1001.com/entry/2021/12/10/040139)

もっとうまい方法があるかもしれないけど, これいいね.

```clojure
(->> data
      (map (fn [d] (...)))
      ((fn [a] (prn a) a))
      (filter (fn [d] (...))))
```


## Clojure 論理式Topics {#5fa3d6}


### 💡doは特殊形式, and/orやThrading Macrosはマクロ {#a7dc2c}

doもandもスレッディングマクロも, 式を手続き的に順次実行評価していくための記法であるという共通点がある.

しかしdoは副作用があっても順次実行する. andやスレッディングマクロは副作用があるフォームを紡いでいくことができない.

そしてand/orはマクロにすぎない, 真偽を返す関数やオペレーターではないというところも, 注意するべき点である.


### 💡Clojure Threading MacrosはR-langのdplyrのpipe記法に似ている {#5682cc}

これは 羽鳥教のdplyrに似てないか？

ref:

-   [羽鳥教のすゝめ ～dplyr編～ | kitayama lab](https://kitayamalab.wordpress.com/2016/05/16/%E7%BE%BD%E9%B3%A5%E6%95%99%E3%81%AE%E3%81%99%E3%82%9D%E3%82%81-%EF%BD%9Edplyr%E7%B7%A8%EF%BD%9E/)
-   [羽鳥教入信のすゝめ - Qiita](https://qiita.com/uri/items/a66b682507181baa0d50)

そしてこの記法の強力な魅力がデータ分析においてR言語をPythonよりも好む人がいるように, Clojureにおいても大変魅力的に違いない.


### 💡threadingとはわたしである {#07c670}

theading = 糸, 筋道. これはつまり, わたしではないか？

ref: [🎓経道とはThreadである]({{< relref "20220209051354.md" >}})
