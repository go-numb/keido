+++
title = "📝Clojure Logics"
lastmod = 2022-08-29T17:01:48+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Core Languages]({{< relref "20220112142936.md" >}})
-   refs.
    -   [📝Clojure フロー制御]({{< relref "20220116083656.md" >}})
    -   [📝Clojure フォーム]({{< relref "20220505210059.md" >}})
    -   [📝nilのハンドリングまとめ]({{< relref "20220302101805.md#0fbf4219-4020-4829-ae01-f057df406c59" >}})

Clojureの論理制御/シーケンス制御のシンタックスまとめ.

ほかのパラダイムだと条件式のロジックで使われるandやorは, Lispの世界だと式を順次評価していくような使い方なので, シーケンス制御と論理制御を合わせてこのメモで扱う.


## Clojure真偽値(true/false) {#25b66742-92cd-4892-b950-6eecc8474ae5}

[📝Clojure フォーム]({{< relref "20220505210059.md" >}})の一つとしての論理値, 真偽値(true/false)


### 💡Clojureの世界における真と偽 {#2830f9}

Clojureではfalseとnilとが偽であり. ほかは真である.

-   空リスト[]は偽ではない. (cf. Common Lisp)
-   0は偽ではない (cf. C言語).


## Clojure 条件式 {#fe1750}

フォームを評価する基本的なものを列挙.

-   true?
-   false?
-   nil?
    -   not-nil?はないが, some?でnil判定はできる.
-   not
-   =
-   not=: not equal
-   empty?
-   seq


### シーケンスに対する述語 {#f26278}

第一引数に条件(predicate), 末尾にCollectionを取る.

> (xxx pred coll)

これらはfilter関数とあわせて用いられる.

-   every?
-   not-any?
-   not-every?

これはcollのみ ([x])

-   any?


### some {#03d59e}

someはシーケンスのいづれかの値が条件を満たすかどうかを判定する.

(some pred coll)

戻り値に注意!

述語がtrueを返したら直ちにその値を返す. 全てがfalseならnilを返す.


## Clojure do 副作用に関わるClojureの述語(do/doto) {#0c94d6da-7462-4a91-9159-8c265b672394}

いわゆるdoなんちゃら.

-   do
-   doto
-   dorun(cf. doall)


### do {#d4579b}

**do** は複数のフォームを手続き的に評価するときに利用する. いちおうなくてもいいけどClojureは関数型パラダイムなので副作用を伴う一連の手続きはdoを書いたほうが親切.

doの戻り値は最後の評価.


### doto {#7e03e1}

**doto** は 第一引数に対して手続き的な操作を行うときに利用する. 主な利用シーンはDBに対してのコマンド発行.

Javaのライブラリをつかうときによくつかう. とくにJavaの[メソッドチェーン]({{< relref "20220117174424.md#57c40755-2b20-4835-af5c-e91cdda3c4c5" >}})が使われている場合. hoge.foo().bar().zzz().


### dorun/doall {#dea9ae38-ea8d-476e-a04e-0149bf17766a}

**dorun**, **doall** は遅延シーケンスのコンテキストで登場する. どちらも遅延評価されたものを強制的に評価して実行する.

そのさい, dorunは単に評価してその結果を考慮せずにnilを返す, つまり副作用があろうが関係ない. 一方doallは遅延シーケンスを評価した結果をシーケンスにして返す.

cf. [Clojure: 遅延評価/遅延シーケンス]({{< relref "20220116094551.md#4f51982f-85bd-4e92-a85e-12cf66360653" >}})


## Clojure and/or Macros {#74ce46df-08ac-453d-a194-b0ff7817511a}

Clojure(というよりもLisp)のandとorはほかのパラダイムとは少し違うことに注意. and と or は条件式(pred)を結合するのに使う. しかし, 真偽値を返すだけではなく, 値そのものが返る.

これは[副作用に関わるClojureの述語(do/doto)](#0c94d6da-7462-4a91-9159-8c265b672394)に近い意味合いなのだ. Lispの世界において, and/or真偽を返すだけのものではない. 順番に式を評価しながら先に進んでいくようなシーケンス制御に使えるような評価器なのだ.

orははじめて真になった値を返してその後の評価を打ち切る. andは真になリ続ける限り次を評価して, falseになったら評価をやめる. これは面白い性質であり, これを用いていろんな制御が書ける. and, orを使いこなすとコードを短くすることができる(ref. [andとorを条件分岐につかう]({{< relref "20220302101805.md#420b5cde-0746-4e0d-879b-0c6697b473c3" >}})).

ref. [(clj 3) Clojure's 'and' and 'or' are weird (but not really) | Joep Schuurkes](https://smallsheds.garden/blog/clojure/2020/clj3-and-or-being-weird/)


## Clojure: Threading Macros {#508f51c6-37cb-4b61-9bce-91075f1f067e}

-   スレッディングマクロ.
-   基本的には **->** と **->>** をつかう.
-   入れ子構造の関数呼び出しを逐次処理な呼び出しに変える.

refs:

-   [clojure.org - Threading Macros Guide](https://clojure.org/guides/threading_macros)
-   [スレッドマクロを整理する - 紙箱](https://boxofpapers.hatenablog.com/entry/threading_macros)


### thread-first (->) と thread-last (->>) {#8df000}

-> も ->>も1つ目のフォームを初期値にして2つ目のフォームから逐次適用していく.

->はフォームの第一引数に引数が入る. 一方, ->>は最終引数に引数が入る.

->> 利用するケースは第一引数に高階関数を受取り末尾にリストを受け取るような関数である.(map, filter, reduce...)

see also: [💡Clojureデータ構造の操作関数の分類]({{< relref "20220116080205.md#582983e0-0ed8-419e-aa14-c9b227ad42f9" >}})


### as-> clojure thread-firstとthead-lastを混在させる {#f8bc06}

thread-as or as->をつかうことで, 混在させられる.

```clojure
(-> [10 11]
    (conj 12)
    (as-> xs (map - xs [3 2 1]))
    (reverse))
; (11 9 7)
```


### cond-> 条件つきスレッドマクロ {#edc8041c-a7eb-4b51-8433-f8b1038b3ffc}

cond->は初期値と(条件, 処理)のリストを受ける. 条件が真のときのみ処理はされる.

```clojure
(cond-> (初期値)
  (条件) (処理)
  (条件) (処理)
  (条件) (処理))
```

もし存在すれば(if-exists)そのデータを初期値に加えるようなときにつかう. 初期値がcollectionで, もしparamが存在すればそれをcollectionにaddやassocやconjみたいなケースでよく見かける.

[条件付きMap操作: assoc-if/update-if 追加する値がnilでなければ操作]({{< relref "20220302101805.md#659c997d-8c8e-4837-a8b3-a60cc77082c4" >}})


### some->/some->> : 副作用のある呼び出しを中断 {#83a26d9b-05ee-4e0f-b052-49f701755297}

ref. [some-> - Threading Macros Guide](https://clojure.org/guides/threading_macros#_some_some_and_cond)

Threadingマクロの途中で副作用のあるJavaの関数(往々にして戻り値がない, つまりnullを返す可能性がある)を呼び出す時, 途中結果がnullならばその後の処理を打ち切る用途としてsome->というスレッディングマクロがある.


### Emacs clojure-mode: M-x clojure-thread {#f4cff6}

Emacs clojure-modeの threadingリファクタリングサポート.

ref: <https://github.com/clojure-emacs/clojure-mode/#refactoring-support>

-   clojure-unwind/clojure-unwind-all:
    -   threading expressionを解く.
-   clojure-thread-first-all: -> へ変換.
-   clojure-thread-last-all: ->> へ変換.

threading macrosを理解するには, ->> の内側で M-x clojure-unwind-allを叩くとスレッディングマクロを使わない場合に変換される. もとに戻すには, M-x clojure-thread-last-all.


### スレッディングマクロの途中で中身をのぞく {#230cf6}

ref. [Clojureで仕事をはじめて１年経った - さめたコーヒー](https://www.kbaba1001.com/entry/2021/12/10/040139)

もっとうまい方法があるかもしれないけど, これいいね.

```clojure
(->> data
      (map (fn [d] (...)))
      ((fn [a] (prn a) a))
      (filter (fn [d] (...))))
```


## Clojure 論理式Topics {#5fa3d6}


### 💡doは特殊形式, and/orやThrading Macrosはマクロ {#a7dc2c}

doもandもスレッディングマクロも, 式を手続き的に順次実行評価していくための記法であるという共通点がある.

しかしdoは副作用があっても順次実行する. andやスレッディングマクロは副作用があるフォームを紡いでいくことができない.

そしてand/orはマクロにすぎない, 真偽を返す関数やオペレーターではないというところも, 注意するべき点である.


### 💡Clojure Threading MacrosはR-langのdplyrのpipe記法に似ている {#5682cc}

これは 羽鳥教のdplyrに似てないか？

ref:

-   [羽鳥教のすゝめ ～dplyr編～ | kitayama lab](https://kitayamalab.wordpress.com/2016/05/16/%E7%BE%BD%E9%B3%A5%E6%95%99%E3%81%AE%E3%81%99%E3%82%9D%E3%82%81-%EF%BD%9Edplyr%E7%B7%A8%EF%BD%9E/)
-   [羽鳥教入信のすゝめ - Qiita](https://qiita.com/uri/items/a66b682507181baa0d50)

そしてこの記法の強力な魅力がデータ分析においてR言語をPythonよりも好む人がいるように, Clojureにおいても大変魅力的に違いない.


### 💡threadingとはわたしである {#07c670}

theading = 糸, 筋道. これはつまり, わたしではないか？

ref: [🎓経道とはThreadである]({{< relref "20220209051354.md" >}})
