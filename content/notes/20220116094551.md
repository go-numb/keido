+++
title = "📝Clojure Functional Programming"
tags = ["WIKI"]
draft = false
+++

いわゆる関数型プログラミングのパラダイムで登場する用語のClojure実現方法.

[Clojure - Clojureを学ぼう - 関数](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/functions)

ref: [📂Clojure Core]({{< relref "20220112142936.md" >}}) [🏷Functional Programming]({{< relref "20220305080412.md" >}})


## Clojure: Function {#clojure-function}

**defn** で定義.

ref: [🔗Clojure - Learn Clojure - Functions](https://clojure.org/guides/learn/functions) [🏷Function]({{< relref "20220305075933.md#function-関数" >}})


### Clojure: Multi-arity Functions {#clojure-multi-arity-functions}

Multi-arity functionsをサポート.

arityはアリティと発音する, 関数の取りうる個数.

```clojure
(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
```

ref: [アリティ | arity]({{< relref "20220305080412.md#アリティ-arity" >}})


### Clojure: 可変長引数関数 | Variadic Functions {#clojure-可変長引数関数-variadic-functions}

[可変長引数]({{< relref "20220305075933.md#関数の引数" >}}) をサポートする関数, variadic = 可変長.

```clojure
(defn hello [greeting & who]
  (println greeting who))
```


## Clojure: 無名関数 {#clojure-無名関数}

Clojureでは無名関数は **fn** で定義する. リーダマクロ **#()** でも表現可能.

---

[🏷無名関数]({{< relref "20220305080412.md#無名関数--annonimous-functions" >}}) [🏷クロージャ]({{< relref "20220305080412.md#無名関数--annonimous-functions" >}})


### Clojure: constantly {#clojure-constantly}

constantlyは 引数を受け取って無名関数を返す.

APIなど3rd party のライブラリを使おうと思ったとき引数に関数を指定しないと使えないときに引数を渡すためのテクニック.


### Clojure: compliment {#clojure-compliment}

関数を受取り, 関数を評価した結果の反対の真偽を返す無名関数を返す.

notのわかりやすい名前をつけるときに使える.
(つまり defによって良い名前で束縛されることを期待).

```clojure
(def not-empty? (complement empty?))

(not-empty? [])    ;;=> false
(not-empty? [1 2]) ;;=> true
```

ref: [complement - ClojureDocs](https://clojuredocs.org/clojure.core/complement)


## Clojure: 関数適用 {#clojure-関数適用}

-   apply: 関数適用
-   partial: 部分適用.
-   comp: 関数合成.


### Clojure: apply | 関数適用 {#clojure-apply-関数適用}

無名関数fnを引数リストargsに適用する.

以下の２つが同じことをしている.

-   (apply str ["str1" "str2" "str3"])
-   (str "str1" "str2" "str3")

ref: [Clojure - Clojureを学ぼう - 関数](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/functions#_%E9%96%A2%E6%95%B0%E3%82%92%E9%81%A9%E7%94%A8%E3%81%99%E3%82%8B)


### Clojure: partial |  部分適用 {#clojure-partial-部分適用}

Clojureではpartialの表記を利用して部分適用する.

複数の引数を取る関数の場合,
partialで適用できるのははじめの引数のみであることに注意(left-apply).

部分適用は一部の引数を固定した無名関数を返すことにすぎないため,
２つ目移行の任意の引数を固定するには自分で無名関数を書くことが必要.

```clojure
(defn foo [x y z]
    (+ x y z))

;; partialだとxしか固定できない.
(def foo1 (partial foo 1))

(def foo2
  (fn [x z] (foo x 2 z)))

(def foo3
  (fn [x y] (foo x y 3)))
```

ref: [部分適用]({{< relref "20220305080412.md#無名関数--annonimous-functions" >}})


### Clojure: comp | 関数合成 {#clojure-comp-関数合成}

複数の部分関数を組み合わせるのはcompをつかう.

[Threading Macros]({{< relref "20220116162321.md#clojure-threading-macros" >}}) は フォームを評価した結果であり,
compは評価するための関数をまとめたものである.

```clojure
(def proc-comp (comp proc1 proc2 proc3))
(def proc-next (fn [x] (proc3 (proc2 (proc1 x))))
(proc-comp x)
(proc-nest x)
```

```clojure
(-> x
    (proc1)
    (proc2)
    (proc3))
```


### Clojure: juxt {#clojure-juxt}

複数の関数を受け取って新しく関数を返し、その関数は受け取った引数をそれぞれの関数に適用した結果をvectorで返す.

ex.) ((juxt a b c) x) => [(a x) (b x) (c x)]

ref: [filter と remove のふたつの結果を簡単に受け取る方法 - Qiita](https://qiita.com/ayato_p/items/db4d6bd8d453f14e13e2)


### Clojureではカリー化をpartialで実現する {#clojureではカリー化をpartialで実現する}

Clojureではカリー化をサポートしておらず,
部分適用関数partialでうまく書き直せる.

表現を正確にするならばHaskellのようなautomatic curryingをサポートしていないので無名関数を駆使して表現を書き換えるが,
partial関数をつかうとその表現方法が簡単に書けるという意.

[💡カリー化と部分適用の違い]({{< relref "20220305080412.md#カリー化-currying" >}}) については別ページでまとめたので要確認.

カリー化というのは表現方法に過ぎないので書き方ではpartial を使おうが使わなかろうが書ける. partialが便利, という話.

[Clojure Style Guide]({{< relref "20220313110515.md#clojure-スタイルガイド" >}}) には
[カリー化には無名関数よりpartialが望ましい](https://totakke.github.io/clojure-style-guide/#partial) との記載あり.

---

-   refs.
    -   [🏷カリー化]({{< relref "20220305080412.md#カリー化-currying" >}})
    -   [Currying & Partial Functions · Practicalli Clojure](https://practical.li/clojure/thinking-functionally/partial-functions.html)


## Clojure: 分配束縛(Destructuring) {#clojure-分配束縛--destructuring}

Clojureでは分配束縛をサポートしている.

-   vectorの中にvectorやmapを書いて表現する.
    -   [[][]], [{}{}]
-   分配束縛したくない変数はvectorなら:as,  mapなら:or で表現する.
-   :keysをつかうと，mapをうけとったらその値をシンボルにバインドできる.

JavaScriptだと分割代入ともいう.

-   [Clojure Destructuring Tutorial and Cheat Sheet · GitHub](https://gist.github.com/john2x/e1dca953548bfdfb9844)
-   [Clojureの分配束縛まとめ - Qiita](https://qiita.com/hatappo/items/41f9b3c7495095508a76)


### 関数の引数で分配束縛をつかう {#関数の引数で分配束縛をつかう}

通常は [[][]]や[{}{}]のように書いて右から左にparseするが,
関数の引数として[[][]]を省略して[[]]とかける.

通常のbinding.

```clojure
(defn foo [a b]
    (println a b))

(defn foo [a b & {:keys [x y]}]
  (println a b x y))
(foo "A" "B" :x "X" :y "Y")  ;; => A B X Y
```

余分なものはひとつにまとめるbinding.

```clojure
(defn foo [a b & args]
    (println a b args))
(foo :a :b :x :y :z) ;; => :a :b (:x :y :z)

(defn foo [& {:as m}]
  (println m))
(foo :x "X" :y "Y") ;; => {:y Y, :x X}
```

keysで必要なものだけ取りつつ残りも取るよくばりパターン.

```clojure
(defn foo [a b & {:keys [x y] :as m}]
  (println a b x y m))
(foo "A" "B" :x "X" :y "Y")
;; => A B X Y {:y Y, :x X}
```

この記法(keyword引数にmapを指定)はClojure 1.11からのサポートなのかな？

[Clojure - Keyword argument functions now also accept maps](https://clojure.org/news/2021/03/18/apis-serving-people-and-programs)

この書き方はつかえそう.

```clojure
(defn some-handler [{:keys [db,,,,] :as req}]
,,)
```

奥が深い...

see also: [関数の引数にデフォルト値を指定するには？]({{< relref "20220302101805.md#関数の引数にデフォルト値を指定するには" >}})


## Clojure: 遅延評価/遅延シーケンス(Laziness Evaluation/Laziness Sequence) {#clojure-遅延評価-遅延シーケンス--laziness-evaluation-laziness-sequence}

-   rangeで, 遅延シーケンスの数列を作成できる.
-   repeatで, 遅延シーケンスのシンボルの繰り返しが作成できる.
-   repeatedlyで, 指定回数だけ無名関数を適用したシーケンスを作成できる.
-   iterateで, 関数適用のシーケンスを作成できる. 数学の漸化式.

遅延シーケンスの実現には doall, dorunを利用する.

ref. [Clojureの繰り返し: map vs doseq]({{< relref "20220116083656.md#clojureの繰り返し-map-vs-doseq" >}})


## Clojure: 再帰(Recursion) {#clojure-再帰--recursion}

-   Clojureではloop/recurを利用することで再帰を実装する.
-   recurを利用すれば末尾再帰がかける.


## Clojure: データ操作 {#clojure-データ操作}

-   mapはシーケンスに関数を適用してシーケンスを返す.
-   filterはシーケンスの要素のそれぞれにpredicateを適用してtrueの要素のみを取り出す.
-   reduce はシーケンスをaccuumurateして単一の戻り値を返す.
-   forはシーケンスを順番通りに通りに取り出す.
    -   手続き的に処理したい場合に使う.
    -   pythonのforeach, zip的な.
-   flattenは入れ子構造の配列を単一シーケンスに変換する.

いろいろあるが手を動かして覚えたほうがいい. 基本的な機能は他の言語でもあるのでシンタックスを覚えるのみ.

シーケンスにはユーティリティ関数もいろいろあるのでその都度覚えよう.

ref. [シーケンスの分離と合流テクニック]({{< relref "20220302101805.md#シーケンスの分離と合流テクニック" >}})


### clojure: filter {#clojure-filter}

与えられたコレクションから条件に合うもの抜き出す.

```clojure
(filter pred coll)
```

**remove** は filterの逆で条件がtrueになるものを取り除く.

[🏷filter]({{< relref "20220305080412.md#高階関数-high-order-functions" >}})


## Active Recalls {#active-recalls}


### Clojure部分適用のシンタックスはなんですか? 部分適用の限定的な性質はなんですか？ {#clojure部分適用のシンタックスはなんですか-部分適用の限定的な性質はなんですか}

partial.

Clojureの部分適用では第一引数のみにしか適用することができない.

第２引数以降を固定したい場合は無名関数で代用する.

ex.) (partial grow "Alice")


### Clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか? スレッディングマクロとどう違いますか？ {#clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか-スレッディングマクロとどう違いますか}

comp

スレッディングマクロはフォームを返すがcompは関数を返すため引数をもらわない限りそれ自体では評価できない.

ex.) (defn surprise [direction]
       ((comp oh-my toggle-grow) direction))


### 配列やマップのデータ構造の要素をそのままbindingする方法はなんですか？ {#配列やマップのデータ構造の要素をそのままbindingする方法はなんですか}

分配束縛 - destructuring


### Clojureのrange, repeat, repeatedlyが共通してもつ性質はなんですか？ {#clojureのrange-repeat-repeatedlyが共通してもつ性質はなんですか}

遅延評価 - Lazy Evaluation


### Clojureにおいて再帰を実現するためのシンタックスはなんですか? {#clojureにおいて再帰を実現するためのシンタックスはなんですか}

loop/recur. 末尾再帰ならrecur.


### Clojureで漸化式のような遅延シーケンスを構築する関数はなんですか？ {#clojureで漸化式のような遅延シーケンスを構築する関数はなんですか}

iterate


### Clojureのconstantly, complementはそれぞれどんな役割ですか？ {#clojureのconstantly-complementはそれぞれどんな役割ですか}

constantlyは引数を受取り無名関数を返す.

complementは関数を受取りその関数の評価結果の真偽をひっくり返した無名関数を返す.


### Clojure: juxtはどんな役割がありますか？ {#clojure-juxtはどんな役割がありますか}

複数の関数を受け取って新しく関数を返し、その関数は受け取った引数をそれぞれの関数に適用した結果をvectorで返す.

ex.) ((juxt a b c) x) => [(a x) (b x) (c x)]
