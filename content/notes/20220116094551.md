+++
title = "📝Clojure Functional Programming"
tags = ["WIKI"]
draft = false
+++

いわゆる関数型プログラミングのパラダイムで登場する用語のClojure実現方法.

ref: [📂Clojure Core]({{< relref "20220112142936.md" >}}) [🏷Functional Programming]({{< relref "20220305080412.md" >}})


## Clojure: Function {#clojure-function}

**defn** で定義.

ref: [🔗Clojure - Learn Clojure - Functions](https://clojure.org/guides/learn/functions) [🏷Function]({{< relref "20220305075933.md#function-関数" >}})


### Clojure: Multi-arity Functions {#clojure-multi-arity-functions}

Multi-arity functionsをサポート.

arityはアリティと発音する, 関数の取りうる個数.

```clojure
(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
```

ref: [アリティ | arity]({{< relref "20220305080412.md#higher-order-programming" >}})


### Clojure: Variadic Functions {#clojure-variadic-functions}

[可変長引数]({{< relref "20220305075933.md#関数の引数" >}}) をサポートする関数, variadic = 可変長.

```clojure
(defn hello [greeting & who]
  (println greeting who))
```


## Clojure: 部分適用(Parcial Application) {#clojure-部分適用--parcial-application}

-   Clojureではpartialの表記を利用して部分関数を適用する.
-   複数の部分関数を組み合わせるのはcompをつかう.


## Clojure: 分配束縛(Destructuring) {#clojure-分配束縛--destructuring}

Clojureでは分配束縛をサポートしている.

-   vectorの中にvectorやmapを書いて表現する.
    -   [[][]], [{}{}]
-   分配束縛したくない変数はvectorなら:as,  mapなら:or で表現する.
-   :keysをつかうと，mapをうけとったらその値をシンボルにバインドできる.

JavaScriptだと分割代入ともいう.

-   [Clojure Destructuring Tutorial and Cheat Sheet · GitHub](https://gist.github.com/john2x/e1dca953548bfdfb9844)
-   [Clojureの分配束縛まとめ - Qiita](https://qiita.com/hatappo/items/41f9b3c7495095508a76)


### 関数の引数で分配束縛をつかう {#関数の引数で分配束縛をつかう}

通常は [[][]]や[{}{}]のように書いて右から左にparseするが,
関数の引数として[[][]]を省略して[[]]とかける.

通常のbinding.

```clojure
(defn foo [a b]
    (println a b))

(defn foo [a b & {:keys [x y]}]
  (println a b x y))
(foo "A" "B" :x "X" :y "Y")  ;; => A B X Y
```

余分なものはひとつにまとめるbinding.

```clojure
(defn foo [a b & args]
    (println a b args))
(foo :a :b :x :y :z) ;; => :a :b (:x :y :z)

(defn foo [& {:as m}]
  (println m))
(foo :x "X" :y "Y") ;; => {:y Y, :x X}
```

keysで必要なものだけ取りつつ残りも取るよくばりパターン.

```clojure
(defn foo [a b & {:keys [x y] :as m}]
  (println a b x y m))
(foo "A" "B" :x "X" :y "Y")
;; => A B X Y {:y Y, :x X}
```

この記法(keyword引数にmapを指定)はClojure 1.11からのサポートなのかな？

[Clojure - Keyword argument functions now also accept maps](https://clojure.org/news/2021/03/18/apis-serving-people-and-programs)

この書き方はつかえそう.

```clojure
(defn some-handler [{:keys [db,,,,] :as req}]
,,)
```

奥が深い...


## Clojure: 遅延評価/遅延シーケンス(Laziness Evaluation/Laziness Sequence) {#clojure-遅延評価-遅延シーケンス--laziness-evaluation-laziness-sequence}

-   rangeで, 遅延シーケンスの数列を作成できる.
-   repeatで, 遅延シーケンスのシンボルの繰り返しが作成できる.
-   repeatedlyで, 指定回数だけ無名関数を適用したシーケンスを作成できる.
-   iterateで, 関数適用のシーケンスを作成できる. 数学の漸化式.


## Clojure: 再帰(Recursion) {#clojure-再帰--recursion}

-   Clojureではloop/recurを利用することで再帰を実装する.
    -   recurを利用すれば末尾再帰がかける.


## Clojure: データ操作 {#clojure-データ操作}

-   mapはシーケンスに関数を適用してシーケンスを返す.
-   filterはシーケンスの要素のそれぞれにpredicateを適用してtrueの要素のみを取り出す.
-   reduce はシーケンスをaccuumurateして単一の戻り値を返す.
-   forは複数のシーケンスを順番通りに通りに取り出す.
    -   pythonのzip的な.
-   flattenは入れ子構造の配列を単一シーケンスに変換する.

いろいろあるが手を動かして覚えたほうがいい. 基本的な機能は他の言語でもあるのでシンタックスを覚えるのみ.


## Active Recalls {#active-recalls}


### Clojureで引数に値をとり新たな関数を返すためのシンタックスはなんですか? {#clojureで引数に値をとり新たな関数を返すためのシンタックスはなんですか}

partial

ex.) (partial grow "Alice")


### Clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか? {#clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか}

comp

ex.) (defn surprise [direction]
       ((comp oh-my toggle-grow) direction))


### プログラミング言語の用語で配列やマップのデータ構造の要素をそのままbindingする方法はなんですか？ {#プログラミング言語の用語で配列やマップのデータ構造の要素をそのままbindingする方法はなんですか}

分配束縛 or 分割代入 - destructuring


### Clojureのrange, repeat, repeatedlyが共通してもつ性質はなんですか？ {#clojureのrange-repeat-repeatedlyが共通してもつ性質はなんですか}

遅延評価 - Lazy Evaluation


### Clojureにおいて再帰を実現するためのシンタックスはなんですか? {#clojureにおいて再帰を実現するためのシンタックスはなんですか}

loop/recur. 末尾再帰ならrecur.


### Clojureで漸化式のような遅延シーケンスを構築する関数はなんですか？ {#clojureで漸化式のような遅延シーケンスを構築する関数はなんですか}

iterate
