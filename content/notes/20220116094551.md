+++
title = "📝Clojure Functional Programming"
tags = ["WIKI"]
draft = false
+++

いわゆる関数型プログラミングのパラダイムで登場する用語のClojure実現方法.

ref: [📂Clojure Core]({{< relref "20220112142936.md" >}}) [🏷Functional Programming]({{< relref "20220305080412.md" >}})


## Clojure: Function {#clojure-function}

**defn** で定義.

ref: [🔗Clojure - Learn Clojure - Functions](https://clojure.org/guides/learn/functions) [🏷Function]({{< relref "20220305075933.md#function-関数" >}})


### Clojure: Multi-arity Functions {#clojure-multi-arity-functions}

Multi-arity functionsをサポート.

arityはアリティと発音する, 関数の取りうる個数.

```clojure
(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
```

ref: [アリティ | arity]({{< relref "20220305080412.md#アリティ-arity" >}})


### Clojure: Variadic Functions {#clojure-variadic-functions}

[可変長引数]({{< relref "20220305075933.md#関数の引数" >}}) をサポートする関数, variadic = 可変長.

```clojure
(defn hello [greeting & who]
  (println greeting who))
```


## Clojure: 無名関数/部分適用/関数合成 {#clojure-無名関数-部分適用-関数合成}

Clojureでは無名関数は **fn** で定義する. **#()** でも表現可能.

Clojureではpartialの表記を利用して部分適用する.

複数の部分関数を組み合わせるのはcompをつかう.

-   partial: 部分適用.
-   comp: 関数合成.
-   constantly
-   apply

---

[🏷無名関数]({{< relref "20220305080412.md#無名関数--annonimous-functions" >}})


### Clojureではカリー化をpartialで実現する {#clojureではカリー化をpartialで実現する}

Clojureではカリー化をサポートしておらず, 部分適用partialで代用する.

表現を正確にするならばHaskellのようなautomatic curryingをサポートしていないので無名関数を駆使して表現を書き換えるが,
partial関数をつかうとその表現方法が簡単に書けるという意.

[💡カリー化と部分適用の違い]({{< relref "20220305080412.md#カリー化-currying" >}}) については別ページでまとめたので要確認.

カリー化というのは表現方法に過ぎないので書き方ではpartial を使おうが使わなかろうが書ける. partialが便利, という話.

[Clojure Style Guide]({{< relref "20220313110515.md#clojure-スタイルガイド" >}}) には
[カリー化には無名関数よりpartialが望ましい](https://totakke.github.io/clojure-style-guide/#partial) との記載あり.

---

-   refs.
    -   [🏷カリー化]({{< relref "20220305080412.md#カリー化-currying" >}})
    -   [Currying &amp; Partial Functions · Practicalli Clojure](https://practical.li/clojure/thinking-functionally/partial-functions.html)


## Clojure: 分配束縛(Destructuring) {#clojure-分配束縛--destructuring}

Clojureでは分配束縛をサポートしている.

-   vectorの中にvectorやmapを書いて表現する.
    -   [[][]], [{}{}]
-   分配束縛したくない変数はvectorなら:as,  mapなら:or で表現する.
-   :keysをつかうと，mapをうけとったらその値をシンボルにバインドできる.

JavaScriptだと分割代入ともいう.

-   [Clojure Destructuring Tutorial and Cheat Sheet · GitHub](https://gist.github.com/john2x/e1dca953548bfdfb9844)
-   [Clojureの分配束縛まとめ - Qiita](https://qiita.com/hatappo/items/41f9b3c7495095508a76)


### 関数の引数で分配束縛をつかう {#関数の引数で分配束縛をつかう}

通常は [[][]]や[{}{}]のように書いて右から左にparseするが,
関数の引数として[[][]]を省略して[[]]とかける.

通常のbinding.

```clojure
(defn foo [a b]
    (println a b))

(defn foo [a b & {:keys [x y]}]
  (println a b x y))
(foo "A" "B" :x "X" :y "Y")  ;; => A B X Y
```

余分なものはひとつにまとめるbinding.

```clojure
(defn foo [a b & args]
    (println a b args))
(foo :a :b :x :y :z) ;; => :a :b (:x :y :z)

(defn foo [& {:as m}]
  (println m))
(foo :x "X" :y "Y") ;; => {:y Y, :x X}
```

keysで必要なものだけ取りつつ残りも取るよくばりパターン.

```clojure
(defn foo [a b & {:keys [x y] :as m}]
  (println a b x y m))
(foo "A" "B" :x "X" :y "Y")
;; => A B X Y {:y Y, :x X}
```

この記法(keyword引数にmapを指定)はClojure 1.11からのサポートなのかな？

[Clojure - Keyword argument functions now also accept maps](https://clojure.org/news/2021/03/18/apis-serving-people-and-programs)

この書き方はつかえそう.

```clojure
(defn some-handler [{:keys [db,,,,] :as req}]
,,)
```

奥が深い...


## Clojure: 遅延評価/遅延シーケンス(Laziness Evaluation/Laziness Sequence) {#clojure-遅延評価-遅延シーケンス--laziness-evaluation-laziness-sequence}

-   rangeで, 遅延シーケンスの数列を作成できる.
-   repeatで, 遅延シーケンスのシンボルの繰り返しが作成できる.
-   repeatedlyで, 指定回数だけ無名関数を適用したシーケンスを作成できる.
-   iterateで, 関数適用のシーケンスを作成できる. 数学の漸化式.

遅延シーケンスの実現には doall, dorunを利用する.

ref. [Clojureの繰り返し: map vs doseq]({{< relref "20220116083656.md#clojureの繰り返し-map-vs-doseq" >}})


## Clojure: 再帰(Recursion) {#clojure-再帰--recursion}

-   Clojureではloop/recurを利用することで再帰を実装する.
-   recurを利用すれば末尾再帰がかける.


## Clojure: データ操作 {#clojure-データ操作}

-   mapはシーケンスに関数を適用してシーケンスを返す.
-   filterはシーケンスの要素のそれぞれにpredicateを適用してtrueの要素のみを取り出す.
-   reduce はシーケンスをaccuumurateして単一の戻り値を返す.
-   forはシーケンスを順番通りに通りに取り出す.
    -   手続き的に処理したい場合に使う.
    -   pythonのforeach, zip的な.
-   flattenは入れ子構造の配列を単一シーケンスに変換する.

いろいろあるが手を動かして覚えたほうがいい. 基本的な機能は他の言語でもあるのでシンタックスを覚えるのみ.


## Active Recalls {#active-recalls}


### Clojureで引数に値をとり新たな関数を返すためのシンタックスはなんですか? {#clojureで引数に値をとり新たな関数を返すためのシンタックスはなんですか}

partial

ex.) (partial grow "Alice")


### Clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか? {#clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか}

comp

ex.) (defn surprise [direction]
       ((comp oh-my toggle-grow) direction))


### プログラミング言語の用語で配列やマップのデータ構造の要素をそのままbindingする方法はなんですか？ {#プログラミング言語の用語で配列やマップのデータ構造の要素をそのままbindingする方法はなんですか}

分配束縛 or 分割代入 - destructuring


### Clojureのrange, repeat, repeatedlyが共通してもつ性質はなんですか？ {#clojureのrange-repeat-repeatedlyが共通してもつ性質はなんですか}

遅延評価 - Lazy Evaluation


### Clojureにおいて再帰を実現するためのシンタックスはなんですか? {#clojureにおいて再帰を実現するためのシンタックスはなんですか}

loop/recur. 末尾再帰ならrecur.


### Clojureで漸化式のような遅延シーケンスを構築する関数はなんですか？ {#clojureで漸化式のような遅延シーケンスを構築する関数はなんですか}

iterate


### Clojureでカリー化と部分適用のための関数はそれぞれなんですか？ {#clojureでカリー化と部分適用のための関数はそれぞれなんですか}
