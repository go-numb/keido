+++
title = "📝Clojure Functional Programming"
tags = ["WIKI"]
draft = false
+++

いわゆる関数型プログラミングのパラダイムで登場する用語のClojure実現方法.

ref: [📂Clojure Core]({{< relref "20220112142936.md" >}}) [🏷Functional Programming]({{< relref "20220305080412.md" >}})


## Clojure: Function {#clojure-function}

**defn** で定義.

ref: [🔗Clojure - Learn Clojure - Functions](https://clojure.org/guides/learn/functions) [🏷Function]({{< relref "20220305075933.md#function-関数" >}})


### Clojure: Multi-arity Functions {#clojure-multi-arity-functions}

Multi-arity functionsをサポート.

arityはアリティと発音する, 関数の取りうる個数.

```clojure
(defn messenger
  ([]     (messenger "Hello world!"))
  ([msg]  (println msg)))
```

ref: [アリティ | arity]({{< relref "20220305080412.md#higher-order-programming" >}})


### Clojure: Variadic Functions {#clojure-variadic-functions}

Variadic functions をサポート. 可変長引数の関数, variadic = 可変引数.

```clojure
(defn hello [greeting & who]
  (println greeting who))
```


## Clojure: 部分適用(Parcial Application) {#clojure-部分適用--parcial-application}

-   Clojureではpartialの表記を利用して部分関数を適用する.
-   複数の部分関数を組み合わせるのはcompをつかう.


## Clojure: 分配束縛(Destructuring) {#clojure-分配束縛--destructuring}

Clojureでは分配束縛をサポートしている.

-   vectorの中にvectorやmapを書いて表現する.
    -   [[][]], [{}{}]
-   分配束縛したくない変数はvectorなら:as,  mapなら:or で表現する.
-   :keysをつかうと，mapをうけとったらその値をシンボルにバインドできる.

JavaScriptだと分割代入ともいう.

-   [Clojure Destructuring Tutorial and Cheat Sheet · GitHub](https://gist.github.com/john2x/e1dca953548bfdfb9844)
-   [Clojureの分配束縛まとめ - Qiita](https://qiita.com/hatappo/items/41f9b3c7495095508a76)


## Clojure: 遅延評価(Laziness) {#clojure-遅延評価--laziness}

-   rangeを利用する遅延シーケンスの数列を作成できる.
-   repeatを利用すると，遅延シーケンスのシンボルの繰り返しが作成できる.
-   repeatedlyを利用すると，指定回数だけ無名関数を適用したシーケンスを作成できる.


## Clojure: 再帰(Recursion) {#clojure-再帰--recursion}

-   Clojureではloop/recurを利用することで再帰を実装する.
    -   recurを利用すれば末尾再帰がかける.


## Clojure: データ操作 {#clojure-データ操作}

-   mapはシーケンスに関数を適用してシーケンスを返す.
-   filterはシーケンスの要素のそれぞれにpredicateを適用してtrueの要素のみを取り出す.
-   reduce はシーケンスをaccuumurateして単一の戻り値を返す.
-   forは複数のシーケンスを順番通りに通りに取り出す.
    -   pythonのzip的な.
-   flattenは入れ子構造の配列を単一シーケンスに変換する.

いろいろあるが手を動かして覚えたほうがいい. 基本的な機能は他の言語でもあるのでシンタックスを覚えるのみ.


## Active Recalls {#active-recalls}


### Clojureで引数に値をとり新たな関数を返すためのシンタックスはなんですか? {#clojureで引数に値をとり新たな関数を返すためのシンタックスはなんですか}

partial

ex.) (partial grow "Alice")


### Clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか? {#clojureで２つの関数から新たな関数を返すためのシンタックスはなんですか}

comp

ex.) (defn surprise [direction]
       ((comp oh-my toggle-grow) direction))


### プログラミング言語の用語で配列やマップのデータ構造の要素をそのままbindingする方法はなんですか？ {#プログラミング言語の用語で配列やマップのデータ構造の要素をそのままbindingする方法はなんですか}

分配束縛 or 分割代入 - destructuring


### Clojureのrange, repeat, repeatedlyが共通してもつ性質はなんですか？ {#clojureのrange-repeat-repeatedlyが共通してもつ性質はなんですか}

遅延評価 - Lazy Evaluation


### Clojureにおいて再帰を実現するためのシンタックスはなんですか? {#clojureにおいて再帰を実現するためのシンタックスはなんですか}

loop/recur. 末尾再帰ならrecur.
