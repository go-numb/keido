+++
title = "📝Clojure REPL Driven Development"
tags = ["WIKI"]
draft = false
+++

[🏷Clojure]({{< relref "20211111225741.md" >}}) [🏷ソフトウェア開発手法]({{< relref "20220214053235.md" >}})

REPL-Oriented Programmingとも. RDDと略されたりもする.

ソースコードを即時にエディタで評価してインライン表示などすることで，素早くフィードバックをえることができる.

正確にはREPLにエディタからソースコードを評価した結果をもらったものを表示だが，操作的にはソースコードと対話するように開発ができる.

TDDは細かくテストを書くことで素早くフィードバックを得ることで先の不安を事前に取り除き前に進むための確信を得ることが目的のひとつだった. 継続的インテグレーション，継続的デリバリーなども.
それらのサイクルの単位よりもRDDは圧倒的にフィードバックが早い! もはや最小単位.


## REPLとは {#replとは}

REPLとは以下の略.

-   read
-   evaluate
-   print
-   loop

REPLの説明は以下がわかりやすかった. 少し抜粋.

ref: [🔗REPL Driven Programming - tyano's Techlog](https://tyano.shelfinc.com/post/48110396231/repl-driven-programming)

REPLでnamespaceを読み込むということは簡易実行環境ではなく **あなたが書いたプログラム内部に潜り込んでコンソールを開いた状態** そのもの. Clojureにインタープリタは存在しない. 関数をバイトコードにして実行するのみ.

---

Road to Common Lispの中で [Lisp as a System](https://gist.github.com/y2q-actionman/49d7587912b2786eb68643afde6ca192#lisp-as-a-system) という章も，例題がCommon Lispではあるものの実体はRDD.

1.  Lispプロセスを起動。
2.  プロジェクトを読み込む。
3.  コードをエディタで編集。
4.  動作中のプロセスに、編集したコードだけをコンパイルさせる。
5.  プロセス中の変更したコードと対話。 REPL や HTTP request などを通して行う。
6.  出力を調査 （コンソール、ブラウザなどで）。3に戻る。

&gt; Common Lispを書くことは、生物や呼吸する組織とやりとりすること、もしくは 熱心な助手に物事を教えることのように感じることができます。

ref: [💻A Road to Common Lisp - Steve Losh(2018)]({{< relref "20220110033325.md" >}})


## EmacsでのClojure REPL Driven Developmentの具体的な方法 {#emacsでのclojure-repl-driven-developmentの具体的な方法}

-   M-x cider-jack-in (REPLにEmacsから接続)
    -   M-x cider-load-file (ファイル単位でevaluate)
    -   M-x cider-eval-last-sexp (フォーム単位でevaluate &amp; インラインで結果表示)
    -   M-x cider-eval-last-sexp-to-repl(フォーム単位でREPLに送信してevaluate)

ref: 🔗[Column: REPL 駆動開発を取り入れて Ring でもう少し遊んでみる — Clojure の日本語ガイド](http://ayato-p.github.io/clojure-beginner/intro_web_development/column_rdd_and_more_ring.html)


## Design Journal {#design-journal}

RDDでコードを書くと，まずごにょごにょとアイデアを文で書いたりそれを小さな関数で実装して評価してみたりを繰り返しながら，つまりエディタと対話しながら小さな部品を組み立てていき，それらを組み合わせて大きな機能をつくる.

そのごにょごにょの部分はソースコードの下のほうにコメントアウトしつつ残しておくことで，どういう設計意図があってこのコードを実装したのかの履歴を，コードとともに残しておこうという考え.

こういうことができるのは，REPLで関数をかんたんに評価できるということもあるが，別の側面としてはClojureが関数型言語なので簡潔に副作用もなく部品としてコードを残しやすいという側面がある(と個人的には思っている).

実際の [Design Journal実施例](https://github.com/practicalli-john/tictactoe-reagent/blob/master/src/tictactoe_reagent/core.cljs#L124) はこちら.

ref: [REPL Driven Development - DEV Community](https://dev.to/jr0cket/repl-driven-development-ano)


### Design Journal Tisp with Clojure Cider {#design-journal-tisp-with-clojure-cider}

**comment** マクロをつかうとまとめてコメントアウトできる.

式の評価結果をそのまま次の行に出力すると後で思い出すときにいちいち評価しなくてもいい.

-   M-x cider-pprint-eval-defun-to-comment
-   M-x cider-pprint-eval-last-sexp-to-comment

ただしcommentと合わせて使うと評価が動かないのでこれをつかうときはcommentを外す.


## Reloaded Workflow {#reloaded-workflow}

Stuart Sierraさんの提唱で有名になった？開発手法(2013).

ref: [🔗Clojure Workflow Reloaded](https://cognitect.com/blog/2013/06/04/clojure-workflow-reloaded)

Clojureの起動,
特にJVMの初回立ち上げが重くて気軽に再起動できないからこそ生まれた工夫.

アプリをシングルトンなJVMとして起動するのではなくてインスタンスとして起動することで古いインスタンスは捨ててしまう(i.e.ガーベージコレクションかな?).

とくにresetを連発してライトにシステム再起動,
CIDERで M-x cider-ns-refreshの前後にsuspendとresumeをhookさせるとよいとか.

.dir-locals.に記載.

```elisp
((clojure-mode . ((cider-ns-refresh-before-fn . "integrant.repl/suspend")
                  (cider-ns-refresh-after-fn  . "integrant.repl/resume"))))
```


### 💡考察: reloaded workflowはdocker-composeに似ている {#考察-reloaded-workflowはdocker-composeに似ている}

コレはたしかによいね, REPLの再起動が結構ストレスだったので. reset 連発するぞ.

docker-composeに発想は似ているな.
dockerごとにサービスを定義してdocker-composeで依存関係を制御しつつ立ち上げるところ.
docker-composeの再起動ってどのくらいの速さだっけ？

しかしreplのみで再起動のほうが速そうではある.
システムテストならdockerまるごと再起動が必要もしれないが少なくもと開発なら気軽にEmacsから再起動したい.


### See also {#see-also}

-   <https://github.com/weavejester/integrant-repl>
    -   integrantにおいて reloaded workflowを実践.
-   [Clojureで快適なREPL駆動開発のために"reloaded workflow"を実践しよう - Qiita](https://qiita.com/lagenorhynque/items/a752ffae490e83ebe70d)
    -   <https://github.com/lagenorhynque/reloaded-workflow-examples>
-   [ミニマリストのためのClojure REST API開発入門2 〜リファクタリング編〜 - Qiita](https://qiita.com/lagenorhynque/items/f1e3c75439c1625756f3#2-integrant-repl%E3%81%AE%E5%B0%8E%E5%85%A5)
    -   integrant-repl deps.edn設定例があった.


## clojure.repl {#clojure-dot-repl}

ClojureのREPLでの便利ツールライブラリ.

[clojure.repl - Clojure v1.10.3 API documentation](https://clojure.github.io/clojure/clojure.repl-api.html)

REPLでrequireでライブラリを一切合切ロードしてつかう.

```clojure
(require '[clojure.repl :refer :all])
```

-   doc: 関数のドキュメントを表示.
    -   cider-doc/cider-clojuredocs/cider-javadocだとEmacs経由で参照できる.
-   source: 関数のソースを表示.


## Clojure RDD Tips {#clojure-rdd-tips}


### tips: 便利ツールをいろいろ導入 {#tips-便利ツールをいろいろ導入}

REPLを起動するとuser.cljが自動的に読み込まれる.
例えばpathに dev/srcを設定してその中に user.cljをおいておくと読み込まれる.

そのuser.cljにREPLで利用する便利関数をいろいろ詰め込んでおくと,
自分専用の開発ToolBoxの完成.


### howto: namespaceの定義を消したい {#howto-namespaceの定義を消したい}

clojure.coreには, [ns-unmap](https://clojuredocs.org/clojure.core/ns-unmap) がありこれでnamespaceからsymbolを消すことができる.

ciderだと cider-undefをつかうとbetter.


## 参考リンク {#参考リンク}

-   [ClojureでREPL駆動開発を始めよう - Qiita](https://qiita.com/lagenorhynque/items/d68934546fa7283bad9d)
-   [REPL Driven Programming - tyano's Techlog](https://tyano.shelfinc.com/post/48110396231/repl-driven-programming)
-   [REPL driven development · Practicalli Clojure](https://practical.li/clojure/repl-driven-development.html)
-   [An Architect's View: Talks: Clojure's Superpower](https://corfield.org/blog/2020/11/24/talks-clojures-superpower/)
    -   [Clojure-Provo December Meeting - REPL-Driven Development – Clojure's
        Superpower - YouTube](https://www.youtube.com/watch?v=skEXGSp10Xs)
    -   [REPL Driven Development, Clojure's Superpower - Sean Corfield - YouTube](https://www.youtube.com/watch?v=gIoadGfm5T8)

---

see also: [🖊REPL 駆動開発について（REPL Driven Development) 調べたメモ | Futurismo](https://futurismo.biz/archives/5717/)


## Active Recalls {#active-recalls}


### REPLとは何の略ですか? {#replとは何の略ですか}

read, evaluate, print, loop


### REPL Driven Developmentとはなんですか？ {#repl-driven-developmentとはなんですか}

REPLを使って対話的に開発を行う手法.

エディタにコードを書いて，REPLに送信して評価して即座にアウトプットのフィードバックを得ることにで，次に何をするかを考えることができる.
