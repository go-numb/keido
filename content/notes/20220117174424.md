+++
title = "📝オブジェクト指向プログラミング"
tags = ["WIKI", "TAG"]
draft = false
+++

up: [📂プログラミングパラダイム]({{< relref "20220116193313.md" >}})

refs:

-   [📝ポリモーフィズム]({{< relref "20220310125619.md" >}})
-   [💻【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人]({{< relref "20220303195740.md" >}})
-   [オブジェクト指向プログラミング - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)


## オブジェクト指向プログラミングとは {#オブジェクト指向プログラミングとは}

オブジェクト指向パラダイムにおけるプログラミング.

以下の要素をそなえもつ.

-   [データ抽象(Data Abstruction)](#データ抽象--data-abstruction)
-   Inheritance
-   Polymorphism

現在オブジェクト指向言語と呼ばれているものは,実際には,

-   Abstruct Data Type (Java Integer 型)
-   オブジェクト (Java Object 型)

の 2 つを合わせもっている.

その意味で, オブジェクト指向言語と言うよりは抽象データ言語というほうが正しい.


## データ抽象(Data Abstruction) {#データ抽象--data-abstruction}

データ抽象, Data Abstruction. [Expression Problem]({{< relref "20220307102236.md" >}}) における解決策.

3 つの構成要素がある.

-   Input
-   Output
-   Interface

データ抽象は内部と外部からなるプログラムかつ,
両者がインターフェースを通じてやりとりするもの.

> A data abstraction is a part of a program that has an inside, an outside,
and an interface in between The inside is hidden from the outside.

データを抽象的に使う, 使い方.実装にとらわれずにデータを使うこと.
インタフェースと呼ばれる規則にしたがって使用される具体化の集合.

データ抽象を型 (Type) といって済ますこともある.
抽象データ型 (ADT) は, 特殊なデータ抽象.
値の集合と, それに関する操作の集合.(CPMCP p431)

以下のコンセプトに支えられている

-   High-order Programming (高階関数)
-   Static Scoping (クロージャ)
-   Explicit State (明示的状態)

Data Abstruction は 2 つの実現方法がある.

-   Abstruct Data Type (ADT)
    -   [Abstract data type: 抽象データ型(ADT)]({{< relref "20220310123730.md#抽象データ型-abstract-data-type--adt" >}})
    -   値と操作をベツベツに保持する.
-   Object
    -   値と操作を一緒に保持する


### Input/Output {#input-output}

内部は外部からは隠蔽されている. -> カプセル化という.

The inside is hidden from the outside


### Interface {#interface}

The interface is a set of operations that an be used according to certain rules.

データ抽象には, 主に二つの方法がある.

-   Abstract Data Type (ADT) keeps values and operations separate.
-   Object groups together value and operations in a single entity.

Java インタフェースは, 階層を持たない型システムを構築する.
(Effective Java p91 抽象クラスよりもインタフェースを選ぶ)


### 抽象クラスよりもインタフェースを選ぶ {#抽象クラスよりもインタフェースを選ぶ}

ref: Effective Java (p93)

実装の観点では,

-   抽象クラスはメソッドに対する実装を含むことを許されている.
-   インタフェースはメソッドに対する実装を含むことを許されていない.

機能の観点では,

-   抽象クラスはある機能の実装を強制する.
-   インタフェースは任意の機能を混ぜ合わせる.

階層化の観点では,

-   抽象クラスは物事を階層化することに優れる.
-   インタフェースは階層を持たないものをまとめることに優れる.

インタフェースは, 階層を持たない型システムを構築する.

-   インタフェースは型を定義するために利用する
-   インタフェースは定数を提供するために使用しない
    -   Enum を検討する
    -   Util クラスを検討する
    -   関連するクラスのメンバを検討する


### SICP における説明 {#sicp-における説明}

データオブジェクトをどう表現するかに関するプログラムの部分を、データオブジェクトをどう使うかに関するプログラムから隔離する方法.(SICP)

constructor(構成子), selector(選択子) によって、どう使うかに関するプログラムの
**抽象の壁** を構築し、抽象レイヤを構築する.

これを、Data Abstruction(データ抽象) という.

データによるレイヤー構造を構築することで複雑なシステムをうまく構築することができる.

抽象の壁という意味は、壁をつくることで、ある場所での変更を局所的なレイヤの変更に封じこめることができる.


## カプセル化(Encapsulation) {#カプセル化--encapsulation}

プログラムと内部と内部をインタフェースで分けること.
カプセル化のメリットは大規模開発をシンプルにする.

-   正しさを保証する.
-   複雑さを解消する.


### カプセル化とはあらゆるものを隠蔽すること {#カプセル化とはあらゆるものを隠蔽すること}

カプセル化がデータ隠蔽というのは狭義の定義.

カプセル化とはあらゆるものを隠蔽すること.

-   データ
-   メソッド
-   実装
-   派生クラス
-   設計の詳細
-   実体化の規則
-   型

流動的要素を探し出してカプセル化する


### 某元チーム先輩エンジニアの発言 {#某元チーム先輩エンジニアの発言}

ある目的をもったモノの集合.(N 氏)
モノには特性 (属性と操作) がある.

アプリケーションを設計するということは,
まずそのアプリケーションで利用されるデータ型を定義するということからはじめる.
(AplInteger, AplString みたいなもの)

その後, 自分が定義したデータ型を操作するインタプリタを設計する.

実装では, Java をつかっているものの,
Java はそれらの抽象データ型のインタプリタでしかない.

抽象データとインタプリタを設計することが設計.
->(内部 DSL のこと?? ドメインモデル設計)


## Abstract Data Type {#abstract-data-type}

OOP を語る上では理解をさけられない.

ref: [Abstract data type: 抽象データ型(ADT)]({{< relref "20220310123730.md#抽象データ型-abstract-data-type--adt" >}})


## オブジェクト(Object) {#オブジェクト--object}

値と操作をひとつのまとまりとしたもの. 以下の構成要素をもつ.

-   値 ・・・ Explicite State (明示的状態 .. 時間とともに変化する値)
-   操作 ・・・ Procedural Data Abstruction (手続的データ抽象)


## メソッドと属性(Methods/Attributes) {#メソッドと属性--methods-attributes}

オブジェクトは内部と外部はインタフェースを通じてやりとりされる.
内部の明示的状態を Attributes (属性),
インタフェースを Methods (メソッド) という.

たとえば, A1 を属性, M1 をメソッドという.

```oz
declare
local
   A1={NewCell 0}
in
   proc {M1 Hoge} end
end
```

これはクラスでもインスタンスでもないことに注意!!


## クラス(Class) {#クラス--class}

[抽象データ型(ADT)]({{< relref "20220310123730.md#抽象データ型-abstract-data-type--adt" >}}) からなるデータ構造.

メソッドと属性を定義する特別なシンタックスを Class という. 属性とメソッドはレコードデータ構造によって管理されているだけである!

Class とは, Pair ( attrs[属性の集合] : methods[メソッドの集合]) )

または, Java ならば, こうかいてもいい.

```java
   HashMap<String, HashSet<String>> attrs = new HashMap<String, HashSet<String>>();
   HashMap<String, HashSet<String>> methods = new HashMap<String, HashSet<String>>();

   attrs.put ("Hoge", new HashSet (Arrays.asList ("attr1", "attr2")));
   methods.put ("Hoge", new HashSet (Arrays.asList ("method1", "method2")));
```

Class という概念によって, オブジェクトの"宣言"と"生成 (new)"を分離する.

-   [クラス (コンピュータ) - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF))

クラスは, 継承・ポリモーフィズム・カプセル化などの,
オブジェクト指向プログラミングにおける重要な概念を実現する強力な手段.


## インスタンス化(Instantiation) {#インスタンス化--instantiation}

オブジェクトは一つのメソッドで,
異なる属性をもつ複数のオブジェクトを生成できる.

この能力を Instantiation (インスタンス化) という.


## Procedure Dispatch {#procedure-dispatch}

オブジェクトは単一なエントリポイントをもつ. (エントリポイント = 呼び出し口)
エントリポイントに渡される引数をメッセージという.

下の例だと, Counter がエントリポイント. エントリポイントに inc,get メッセージを送る.

```oz
   {Counter inc}
   {Counter get (X)}
```

エントリポイントから, メッセージに対応するプロシージャが呼びだされる.

メッセージとプロシージャはあらかじめ Dispatch (バンドリング) されている.


## ポリモーフィズム {#ポリモーフィズム}

各要素 (定数, 変数, 式, オブジェクト, 関数, メソッドなど)
についてそれらが複数の型に属することを許すという性質.

-   [ポリモーフィズム - Wikipedia](http://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0)

詳細はこっち: [📝ポリモーフィズム]({{< relref "20220310125619.md" >}})

ポリモーフィズムはオブジェクト指向固有の概念ではない.
以下はOOの観点からポリモーフィズムを説明.


### インタフェース: Interface {#インタフェース-interface}

抽象データ型のメソッド.

Object 型を分類し,
同じカテゴリに属するクラスに共通のインターフェイスを取り決める.

implements ステートメントは, クラスたちのカテゴリ分類を明確にする方法.

変数の型としてカテゴリクラスを指定すると,
そのカテゴリを Implements したクラス (つまり, カテゴリに属するクラス)
のインスタンスも格納できるようになる.

-   [ポリモーフィズムとインターフェイス](http://homepage1.nifty.com/CavalierLab/lab/vb/clsmdl/polymorphism_02.html)

オブジェクトが, 共通のインターフェイスを実装している場合,
他のオブジェクトに置き換えることができる.


### 継承: Inheritance {#継承-inheritance}

継承. あるオブジェクトが他のオブジェクトの特性を引き継ぐこと.

-   [継承 (プログラミング) - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E6%89%BF_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0))

継承は単に特殊化と再利用を実現する手段ではない.
オブジェクトを分類するための手段である.


#### どう分類するか? {#どう分類するか}

-   共通性: 時がたっても変わらないものを抽象クラスに
-   可変性: 流動的要素を具象クラスに.

クラスの集合がもつすべての責務を真っ当するためにインタフェースを用意する.


#### 機能追加と機能実装の違い {#機能追加と機能実装の違い}

-   「機能追加」 (スーパークラスが持っていない機能をサブクラスで追加) を目的としたもの
-   「機能実装」 (スーパークラスで定義したインタフェースをサブクラスで実装) を目的としたもの

ref: :[Bridge パターン - デザインパターン入門 - IT 専科](http://www.itsenka.com/contents/development/designpattern/bridge.html)


### オーバーライド: override {#オーバーライド-override}

オブジェクト指向プログラミングにおいてオーバーライド (override) とは,
スーパークラスで定義されたメソッドをサブクラスで定義しなおし,
動作を上書きすること.

-   [オーバーライド - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89)


## 委譲: Delegation {#委譲-delegation}

委譲(Delegation).

あるオブジェクトの操作を一部他のオブジェクトに代替させる手法.

-   委譲を行うオブジェクトは委譲先オブジェクトへの参照を持つ
-   必要に応じてその参照を切り替える事で動作にバリエーションを持たせる事ができる
-   プラグイン機構

ref: [委譲 - Wikipedia](http://ja.wikipedia.org/wiki/%E5%A7%94%E8%AD%B2)


### コンポジションと移譲の比較 {#コンポジションと移譲の比較}

-   委譲の実現には多くの場合コンポジションを使用する.
    委譲は「目的」であり, コンポジションはその「手段」.

ref: [コンポジションとデリゲーション - とある技術メモブログ](http://d.hatena.ne.jp/earu/20100525/1274794979)


#### Composition {#composition}

コンポジション.

新たなクラスに, 既存クラスのインスタンスを保持する.

has-a の関係 (not is-a)

Prefer Composition over inheritance (Effective Java).


### 継承と委譲の比較 {#継承と委譲の比較}

メリット

-   Java の場合継承は一クラスしかできないが, 委譲なら複数可能
-   継承なら親クラスのメソッドが全て公開されてしまうが委譲なら必要なものだけ公開できる

デメリット

-   継承に比べてコードの記述量が多くなる.
    継承は何も書かなければ親クラスの機能が使える.
    委譲はメソッドの呼び出しを実装しなくてはならない.

ref: [オブジェクト指向で. 継承の他に, 委譲といのが出てきますが. これは具... - Yahoo! 知恵袋](http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q14103428069)


### 関連する Design Pattern {#関連する-design-pattern}

-   Adapter
-   Proxy
-   Facade
-   State
-   Strategy
-   Decorator

ref: [Tricorn Labs » State パターンと Strategy パターンは何が違うのか考える](http://lab.tricorn.co.jp/toda/1088)


## 手続き型とオブジェクト指向の違い {#手続き型とオブジェクト指向の違い}

ref: [📝手続き型プログラミング]({{< relref "20220305083612.md" >}})


### 機能分解 {#機能分解}

ある問題を小さな機能にブレークダウンすることで,
その問題を構成する機能要素の洗い出しをすることを機能分解と呼ぶ.


### 構造化プログラミング的アプローチ {#構造化プログラミング的アプローチ}

-   (手続き的な) 機能を適切な順序で呼び出す「メイン」プログラムが必要になる.
-   メインプログラムにはすべてを正しく動作させる,
    -   すなわち機能の組み合わせと呼び出し順序を制御するあまりに大きな責任が課せられる
-   結果的にソースコードは複雑になる


### オブジェクト指向的アプローチ {#オブジェクト指向的アプローチ}

-   部分機能に対してそれ自体の振舞いに関する責任を持たせ,
    実行指示を行うだけであと任せておく.
-   これが委譲 (delegation) という考え方.


## オブジェクト指向のこころ読書メモ {#オブジェクト指向のこころ読書メモ}


### OOP の 2 大原則 {#oop-の-2-大原則}

オブジェクト指向のこころとは, ズバリ以下だ.

-   流動的要素を探し出してカプセル化する
-   クラス継承よりもオブジェクトの集約を多用する


### オブジェクト指向設計 {#オブジェクト指向設計}

[オブジェクト指向分析設計 - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E5%88%86%E6%9E%90%E8%A8%AD%E8%A8%88)


#### 名詞/ 動詞 抽出法 {#名詞-動詞-抽出法}

-   問題領域に存在する名詞を洗い出しそれらを表現するオブジェクトを生成する.
-   名詞に関連した動詞を洗い出し,それらを表現するメソッドを追加する


#### 共通性/ 可変性 分析法 {#共通性-可変性-分析法}

-   共通性分析:
    -   時間が経っても変化しにくい構造を見つけるもの
    -   共通性分析によってまとめられた概念を抽象クラスによって表現
-   可変性分析:
    -   変化しやすい構造を洗い出すもの
    -   可変性分析で得た流動的要素は抽象クラスの派生クラスによって実装される

設計手順:

-   (抽象クラス) このクラスが持つ責務をすべて全うするにはどうようなインターフェイスが必要か?
-   (派生クラス) この特定実装の中でどうのようにして与えられた仕様を実装できるのか?

Jim Coplien が提唱. p235 第 15 章から抜粋.


#### References {#references}

-   [オブジェクト指向の本懐 (7) ・オブジェクト指向分析 - Strategic Choice](http://d.hatena.ne.jp/asakichy/20090428/1240878836)
-   [共通性・可変性分析 (commonality/variavility analysis) - Debuginfo](http://shoheik.hatenablog.com/entry/20120917/1347838230)


## Is-a/has-a関係 {#is-a-has-a関係}


### Is-a: 継承関係 {#is-a-継承関係}

Is-a は 継承関係.

-   [is-a - Wikipedia](http://ja.wikipedia.org/wiki/Is-a)

Is-a 信仰. なんでも継承すればいいという考え方.


### Has-a: 包含関係 {#has-a-包含関係}

Has-a は 包含関係 (委譲)

-   [has-a - Wikipedia](http://ja.wikipedia.org/wiki/Has-a)


## References {#references}

ものすごくよい記事.歴史が端的にまとまっている.

-   [新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡 - Qiita](http://qiita.com/hirokidaichi/items/591ad96ab12938878fe1)

    > むだに Hoge インタフェースと HogeImpl クラスがあったり,
    > むだに new するだけの create メソッドがあったり,
    > どこで値が設定されてるかわからないオブジェクトがひきまわされてたり,
    > ソースコードを追いにくくするためにやってるとしか思えない,
    > オブジェクト指向なコードをよく目にする.
    >
    > クラスは単にユーザー定義型であり,
    > 継承は部分型と差分プログラミングを実現する仕組みだととらえるのがいい.
    > オブジェクトがメッセージを送りあうとかメルヘンの世界には入らず, 機能だけ考えるのがいい.

    -   [オブジェクト指向は禁止するべき - きしだのはてな](http://d.hatena.ne.jp/nowokay/20140718#1405691217)


### eesay: Rees by Jonathan Rees {#eesay-rees-by-jonathan-rees}

ref: [Rees Re: OO](http://practical-scheme.net/trans/reesoo-j.html#)

オブジェクト指向というのは, このリストのいろいろなサブセットとして 定義されているようだ.
つまり, 「オブジェクト指向」というのはちゃんと定義された概念ではない!


#### カプセル化 {#カプセル化}

型の実装を構文的に隠蔽できること.
例えば C や Pascal では何かが構造体であるか配列であるか常に意識することになるが,
CLU や Java ではその違いを隠すことができる.


#### 保護 {#保護}

型の使用者がその実装をのぞくことができないこと.
これによって,ふるまいさえ変えなければ,
実装を変更しても型の使用者に影響を与えないことが保障でき,
またパスワードのような情報が漏れ出さないようにることもできる.


#### アドホックポリモルフィズム {#アドホックポリモルフィズム}

関数やパラメータつきデータ構造が たくさんの異なる型の値をとることができる.


#### パラメトリックポリモルフィズム {#パラメトリックポリモルフィズム}

関数やデータ構造が任意の値 (例:任意のオブジェクトのリスト)
に対してパラメタライズできること.

ML と Lisp はこれを持つ.
Java は非 Object な型のために, これを完全に持つとは言えない.


#### 全てはオブジェクトなり {#全てはオブジェクトなり}

全ての値はオブジェクト. Smalltalk では真だが, Java では (int 等のため) 真ではない.


#### メッセージを送ることだけができる (All you can do is send a message, {#メッセージを送ることだけができる-all-you-can-do-is-send-a-message}

AYCDISAM) = Actor モデル

オブジェクトを直接いじることはできず,
それと通信する, もしくはそれを起動することのみができる.
Java における field の存在はこれに反する.


#### 仕様継承 = サブタイピング {#仕様継承-サブタイピング}

ふたつの異なる型で, 一方の型の値が もう一方の型の値として使われても型の正当性を破らないことを言語が保障できるようなもの.

(例: Java のインタフェース継承).


#### 実装継承, 再利用 ひとまとまりのコードを書いたら, それと似たコード {#実装継承-再利用-ひとまとまりのコードを書いたら-それと似たコード}

(そのスーパーセット) が制御された方法で生成できる.

つまりコードをコピーして編集する必要がない.
制限された, 特殊な抽象化である. (例:Java のクラス継承).


#### 「関数の積和 (sum-of-product-of-function) 」パターン {#関数の積和--sum-of-product-of-function--パターン}

オブジェクトは (実質的に) 有限の簡単な名前の集合から選ばれるキー引数を第一引数に取り, それによってメソッドを呼び出す関数として動作する.


### Books {#books}

-   オブジェクト指向入門
    -   上下巻あるみたい.
    -   [Amazon.co.jp: オブジェクト指向入門 第 2 版 原則・コンセプト ](http://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E5%85%A5%E9%96%80-%E7%AC%AC2%E7%89%88-%E5%8E%9F%E5%89%87%E3%83%BB%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88-Architect%E2%80%99Archive-%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0/dp/4798111112)
    -   [Amazon.co.jp: オブジェクト指向入門 第 2 版 方法論・実践](http://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E5%85%A5%E9%96%80-%E6%96%B9%E6%B3%95%E8%AB%96%E3%83%BB%E5%AE%9F%E8%B7%B5-Architects%E2%80%99Archive-CLASSIC-MODER/dp/4798111120/ref=pd_sim_b_1?ie=UTF8&refRID=10TRKTN3AGS2XRK96A2Q)
