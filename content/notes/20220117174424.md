+++
title = "📝オブジェクト指向プログラミング"
tags = ["WIKI", "TAG"]
draft = false
+++

-   up: [📂プログラミングパラダイム]({{< relref "20220116193313.md" >}})
-   refs:
    -   [📝ポリモーフィズム]({{< relref "20220310125619.md" >}})
    -   [📝オブジェクト指向設計]({{< relref "20220516232308.md" >}})
    -   [💻【超絶IQ列伝】苫米地メソッド EX 「抽象度とは何か？」苫米地英人]({{< relref "20220303195740.md" >}})
    -   [オブジェクト指向プログラミング - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)


## オブジェクト指向プログラミングとは {#オブジェクト指向プログラミングとは}

オブジェクト指向パラダイムにおけるプログラミング.

以下の要素をそなえもつ.

-   [データ抽象(Data Abstruction)](#データ抽象--data-abstruction)
-   Inheritance
-   Polymorphism

現在オブジェクト指向言語と呼ばれているものは,実際には,

-   Abstruct Data Type (Java Integer 型)
-   オブジェクト (Java Object 型)

の 2 つを合わせもっている.

その意味で, オブジェクト指向言語と言うよりは抽象データ言語というほうが正しい.


## データ抽象(Data Abstruction) {#データ抽象--data-abstruction}

データ抽象, Data Abstruction. [Expression Problem]({{< relref "20220307102236.md" >}}) における解決策.

3 つの構成要素がある.

-   Input
-   Output
-   Interface

データ抽象は内部と外部からなるプログラムかつ,
両者がインターフェースを通じてやりとりするもの.

> A data abstraction is a part of a program that has an inside, an outside, and an interface in between The inside is hidden from the outside.

データを抽象的に使う, 使い方.実装にとらわれずにデータを使うこと. インタフェースと呼ばれる規則にしたがって使用される具体化の集合.

データ抽象を型 (Type) といって済ますこともある. 抽象データ型 (ADT) は, 特殊なデータ抽象. 値の集合と, それに関する操作の集合.(CPMCP p431)

以下のコンセプトに支えられている

-   High-order Programming (高階関数)
-   Static Scoping (クロージャ)
-   Explicit State (明示的状態)

Data Abstruction は 2 つの実現方法がある.

-   Abstruct Data Type (ADT)
    -   [Abstract data type: 抽象データ型(ADT)]({{< relref "20220310123730.md#抽象データ型-abstract-data-type--adt" >}})
    -   値と操作をベツベツに保持する.
-   Object
    -   値と操作を一緒に保持する


### Input/Output {#input-output}

内部は外部からは隠蔽されている. -> カプセル化という.

The inside is hidden from the outside


### Interface {#interface}

The interface is a set of operations that an be used according to certain rules.

データ抽象には, 主に二つの方法がある.

-   Abstract Data Type (ADT) keeps values and operations separate.
-   Object groups together value and operations in a single entity.

Java インタフェースは, 階層を持たない型システムを構築する.
(Effective Java p91 抽象クラスよりもインタフェースを選ぶ)


### 抽象クラスよりもインタフェースを選ぶ {#抽象クラスよりもインタフェースを選ぶ}

ref: Effective Java (p93)

実装の観点では,

-   抽象クラスはメソッドに対する実装を含むことを許されている.
-   インタフェースはメソッドに対する実装を含むことを許されていない.

機能の観点では,

-   抽象クラスはある機能の実装を強制する.
-   インタフェースは任意の機能を混ぜ合わせる.

階層化の観点では,

-   抽象クラスは物事を階層化することに優れる.
-   インタフェースは階層を持たないものをまとめることに優れる.

インタフェースは, 階層を持たない型システムを構築する.

-   インタフェースは型を定義するために利用する
-   インタフェースは定数を提供するために使用しない
    -   Enum を検討する
    -   Util クラスを検討する
    -   関連するクラスのメンバを検討する


### SICP における説明 {#sicp-における説明}

データオブジェクトをどう表現するかに関するプログラムの部分を, データオブジェクトをどう使うかに関するプログラムから隔離する方法.(SICP)

constructor(構成子), selector(選択子) によって、どう使うかに関するプログラムの **抽象の壁** を構築し、抽象レイヤを構築する.

これを、Data Abstruction(データ抽象) という.

データによるレイヤー構造を構築することで複雑なシステムをうまく構築することができる.

抽象の壁という意味は、壁をつくることで、ある場所での変更を局所的なレイヤの変更に封じこめることができる.


## カプセル化(Encapsulation) {#カプセル化--encapsulation}

プログラムと内部と内部をインタフェースで分けること. カプセル化のメリットは大規模開発をシンプルにする.

-   正しさを保証する.
-   複雑さを解消する.


### カプセル化とはあらゆるものを隠蔽すること {#カプセル化とはあらゆるものを隠蔽すること}

カプセル化がデータ隠蔽というのは狭義の定義.

カプセル化とはあらゆるものを隠蔽すること.

-   データ
-   メソッド
-   実装
-   派生クラス
-   設計の詳細
-   実体化の規則
-   型

流動的要素を探し出してカプセル化する


### 某元チーム先輩エンジニアの発言 {#某元チーム先輩エンジニアの発言}

ある目的をもったモノの集合(N 氏).モノには特性 (属性と操作) がある.

アプリケーションを設計するということは, まずそのアプリケーションで利用されるデータ型を定義するということからはじめる. (AplInteger, AplString みたいなもの). その後, 自分が定義したデータ型を操作するインタプリタを設計する.

実装では, Java をつかっているものの, Java はそれらの抽象データ型のインタプリタでしかない. 抽象データとインタプリタを設計することが設計.


## Abstract Data Type {#abstract-data-type}

OOP を語る上では理解をさけられない.

ref: [Abstract data type: 抽象データ型(ADT)]({{< relref "20220310123730.md#抽象データ型-abstract-data-type--adt" >}})


## オブジェクト(Object) {#オブジェクト--object}

値と操作をひとつのまとまりとしたもの. 以下の構成要素をもつ.

-   値 ・・・ Explicite State (明示的状態 .. 時間とともに変化する値)
-   操作 ・・・ Procedural Data Abstruction (手続的データ抽象)


## メソッドと属性(Methods/Attributes) {#メソッドと属性--methods-attributes}

オブジェクトは内部と外部はインタフェースを通じてやりとりされる. 内部の明示的状態を Attributes (属性), インタフェースを Methods (メソッド) という.

たとえば, A1 を属性, M1 をメソッドという.

```oz
declare
local
   A1={NewCell 0}
in
   proc {M1 Hoge} end
end
```

これはクラスでもインスタンスでもないことに注意!!


## クラス(Class) {#クラス--class}

[抽象データ型(ADT)]({{< relref "20220310123730.md#抽象データ型-abstract-data-type--adt" >}}) からなるデータ構造.

メソッドと属性を定義する特別なシンタックスを Class という. 属性とメソッドはレコードデータ構造によって管理されているだけである!

Class とは, Pair ( attrs[属性の集合] : methods[メソッドの集合]) )

または, Java ならば, こうかいてもいい.

```java
   HashMap<String, HashSet<String>> attrs = new HashMap<String, HashSet<String>>();
   HashMap<String, HashSet<String>> methods = new HashMap<String, HashSet<String>>();

   attrs.put ("Hoge", new HashSet (Arrays.asList ("attr1", "attr2")));
   methods.put ("Hoge", new HashSet (Arrays.asList ("method1", "method2")));
```

Class という概念によって, オブジェクトの"宣言"と"生成 (new)"を分離する.

-   [クラス (コンピュータ) - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%A9%E3%82%B9_(%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF))

クラスは, 継承・ポリモーフィズム・カプセル化などの, オブジェクト指向プログラミングにおける重要な概念を実現する強力な手段.


## インスタンス化(Instantiation) {#インスタンス化--instantiation}

オブジェクトは一つのメソッドで, 異なる属性をもつ複数のオブジェクトを生成できる. この能力を Instantiation (インスタンス化) という.


## Procedure Dispatch {#procedure-dispatch}

オブジェクトは単一なエントリポイントをもつ. (エントリポイント = 呼び出し口) エントリポイントに渡される引数をメッセージという. 下の例だと, Counter がエントリポイント. エントリポイントに inc,get メッセージを送る.

```oz
   {Counter inc}
   {Counter get (X)}
```

エントリポイントから, メッセージに対応するプロシージャが呼びだされる.

メッセージとプロシージャはあらかじめ Dispatch (バンドリング) されている.


## ポリモーフィズム {#ポリモーフィズム}

各要素 (定数, 変数, 式, オブジェクト, 関数, メソッドなど) についてそれらが複数の型に属することを許すという性質.

-   [ポリモーフィズム - Wikipedia](http://ja.wikipedia.org/wiki/%E3%83%9D%E3%83%AA%E3%83%A2%E3%83%BC%E3%83%95%E3%82%A3%E3%82%BA%E3%83%A0)

詳細はこっち: [📝ポリモーフィズム]({{< relref "20220310125619.md" >}})

ポリモーフィズムはオブジェクト指向固有の概念ではない. 以下はOOの観点からポリモーフィズムを説明.


### インタフェース: Interface {#インタフェース-interface}

抽象データ型のメソッド.

Object 型を分類し, 同じカテゴリに属するクラスに共通のインターフェイスを取り決める.

implements ステートメントは, クラスたちのカテゴリ分類を明確にする方法.

変数の型としてカテゴリクラスを指定すると, そのカテゴリを Implements したクラス (つまり, カテゴリに属するクラス) のインスタンスも格納できるようになる.

-   [ポリモーフィズムとインターフェイス](http://homepage1.nifty.com/CavalierLab/lab/vb/clsmdl/polymorphism_02.html)

オブジェクトが共通のインターフェイスを実装している場合, 他のオブジェクトに置き換えることができる.


### 継承: Inheritance {#継承-inheritance}

継承. あるオブジェクトが他のオブジェクトの特性を引き継ぐこと.

-   [継承 (プログラミング) - Wikipedia](http://ja.wikipedia.org/wiki/%E7%B6%99%E6%89%BF_(%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0))

継承は単に特殊化と再利用を実現する手段ではない. オブジェクトを分類するための手段である.

---

どう分類するか? 2つの切り口がある.

-   共通性: 時がたっても変わらないものを抽象クラスに
-   可変性: 流動的要素を具象クラスに.

クラスの集合がもつすべての責務を真っ当するためにインタフェースを用意する.


### 機能追加と機能実装の違い {#機能追加と機能実装の違い}

-   「機能追加」 (スーパークラスが持っていない機能をサブクラスで追加) を目的としたもの
-   「機能実装」 (スーパークラスで定義したインタフェースをサブクラスで実装) を目的としたもの

ref: :[Bridge パターン - デザインパターン入門 - IT 専科](http://www.itsenka.com/contents/development/designpattern/bridge.html)


### オーバーライド: override {#オーバーライド-override}

オブジェクト指向プログラミングにおいてオーバーライド (override) とは, スーパークラスで定義されたメソッドをサブクラスで定義しなおし, 動作を上書きすること.

-   [オーバーライド - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%AA%E3%83%BC%E3%83%90%E3%83%BC%E3%83%A9%E3%82%A4%E3%83%89)


## 委譲: Delegation {#委譲-delegation}

委譲(Delegation). あるオブジェクトの操作を一部他のオブジェクトに代替させる手法.

-   委譲を行うオブジェクトは委譲先オブジェクトへの参照を持つ
-   必要に応じてその参照を切り替える事で動作にバリエーションを持たせる事ができる.
-   プラグイン機構

ref: [委譲 - Wikipedia](http://ja.wikipedia.org/wiki/%E5%A7%94%E8%AD%B2)


### コンポジション | Composition {#コンポジション-composition}

新たなクラスに, 既存クラスのインスタンスを保持する.

has-a の関係 (not is-a)

Prefer Composition over inheritance (Effective Java).


### コンポジションと移譲の比較 {#コンポジションと移譲の比較}

委譲の実現には多くの場合コンポジションを使用する. 委譲は「目的」であり, コンポジションはその「手段」.

ref: [コンポジションとデリゲーション - とある技術メモブログ](http://d.hatena.ne.jp/earu/20100525/1274794979)


### 継承と委譲の比較 {#継承と委譲の比較}

メリット

-   Java の場合継承は一クラスしかできないが, 委譲なら複数可能.
-   継承なら親クラスのメソッドが全て公開されてしまうが委譲なら必要なものだけ公開できる.

デメリット

-   継承に比べてコードの記述量が多くなる.
-   継承は何も書かなければ親クラスの機能が使える.
-   委譲はメソッドの呼び出しを実装しなくてはならない.

ref: [オブジェクト指向で. 継承の他に, 委譲といのが出てきますが. これは具](http://detail.chiebukuro.yahoo.co.jp/qa/question_detail/q14103428069)


### 関連する Design Pattern {#関連する-design-pattern}

-   Adapter
-   Proxy
-   Facade
-   State
-   Strategy
-   Decorator


## 手続き型とオブジェクト指向の違い {#手続き型とオブジェクト指向の違い}

ref: [📝手続き型プログラミング]({{< relref "20220305083612.md" >}})


### 機能分解 {#機能分解}

ある問題を小さな機能にブレークダウンすることで, その問題を構成する機能要素の洗い出しをすることを機能分解と呼ぶ.


### 構造化プログラミング的アプローチ {#構造化プログラミング的アプローチ}

(手続き的な) 機能を適切な順序で呼び出す「メイン」プログラムが必要になる.

メインプログラムにはすべてを正しく動作させる, すなわち機能の組み合わせと呼び出し順序を制御するあまりに大きな責任が課せられる.

結果的にソースコードは複雑になる.


### オブジェクト指向的アプローチ {#オブジェクト指向的アプローチ}

部分機能に対してそれ自体の振舞いに関する責任を持たせ, 実行指示を行うだけであと任せておく. これが委譲 (delegation) という考え方.


## Is-a/has-a関係 {#is-a-has-a関係}

Is-a は 継承関係. Has-a は 包含関係 (委譲)

-   [is-a - Wikipedia](http://ja.wikipedia.org/wiki/Is-a)
-   [has-a - Wikipedia](http://ja.wikipedia.org/wiki/Has-a)

Is-a 信仰. なんでも継承すればいいという考え方.


## References {#references}

ref. [💻essay: Rees by Jonathan Rees]({{< relref "20220525212554.md" >}})

---

ものすごくよい記事.歴史が端的にまとまっている.

-   [新人プログラマに知っておいてもらいたい人類がオブジェクト指向を手に入れるまでの軌跡 - Qiita](http://qiita.com/hirokidaichi/items/591ad96ab12938878fe1)

    > むだに Hoge インタフェースと HogeImpl クラスがあったり,
    > むだに new するだけの create メソッドがあったり,
    > どこで値が設定されてるかわからないオブジェクトがひきまわされてたり,
    > ソースコードを追いにくくするためにやってるとしか思えない,
    > オブジェクト指向なコードをよく目にする.
    >
    > クラスは単にユーザー定義型であり,
    > 継承は部分型と差分プログラミングを実現する仕組みだととらえるのがいい.
    > オブジェクトがメッセージを送りあうとかメルヘンの世界には入らず, 機能だけ考えるのがいい.

-   [オブジェクト指向は禁止するべき - きしだのはてな](http://d.hatena.ne.jp/nowokay/20140718#1405691217)


### Books {#books}

-   オブジェクト指向入門
    -   上下巻あるみたい.
    -   [Amazon.co.jp: オブジェクト指向入門 第 2 版 原則・コンセプト ](http://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E5%85%A5%E9%96%80-%E7%AC%AC2%E7%89%88-%E5%8E%9F%E5%89%87%E3%83%BB%E3%82%B3%E3%83%B3%E3%82%BB%E3%83%97%E3%83%88-Architect%E2%80%99Archive-%E3%82%AF%E3%83%A9%E3%82%B7%E3%83%83%E3%82%AF%E3%83%A2%E3%83%80%E3%83%B3%E3%83%BB%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0/dp/4798111112)
    -   [Amazon.co.jp: オブジェクト指向入門 第 2 版 方法論・実践](http://www.amazon.co.jp/%E3%82%AA%E3%83%96%E3%82%B8%E3%82%A7%E3%82%AF%E3%83%88%E6%8C%87%E5%90%91%E5%85%A5%E9%96%80-%E6%96%B9%E6%B3%95%E8%AB%96%E3%83%BB%E5%AE%9F%E8%B7%B5-Architects%E2%80%99Archive-CLASSIC-MODER/dp/4798111120/ref=pd_sim_b_1?ie=UTF8&refRID=10TRKTN3AGS2XRK96A2Q)
