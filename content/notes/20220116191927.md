+++
title = "📝Clojure State and Concurrency"
lastmod = 2022-10-05T19:37:22+09:00
tags = ["WIKI"]
draft = false
+++

Clojureの並行プログラミングについて.

-   up: [📂Clojure Core]({{< relref "20220112142936.md" >}})
-   refs:
    -   [🔖Concurrent Programming]({{< relref "20220116195030.md" >}})
    -   [Clojure: 状態管理とシステム]({{< relref "20220211142329.md#497a8160-d192-45db-aa0c-84b9a2442861" >}})


## Clojure: 状態(State) {#bf0a21}

状態とは，ある時系列におけるある時点での [同一実体]({{< relref "20220116195030.md#98601b3a-f18c-41c5-b5bd-171bc8b11782" >}}) である.

Clojureにおいて値は [immutable]({{< relref "20220114074914.md#fbc351d5-b1d2-4dcd-95cd-9d5021f88565" >}}) であり [persistent]({{< relref "20220114074914.md#7e585ab7-a40f-4a1e-aeaa-812eb632f2ff" >}}) である.

しかし，変更不可なオブジェクトに対して変更可能な参照を作成することで変更不可のものを管理することができる.

Clojureでは，値と同一実体を明確に区別して扱う. 4つの参照型を用意している.

-   ref: 協調的，同期的な変更を管理.
-   atom: 独立的, 同期的な変更を管理.
-   agent: 非同期な変更を管理.
-   var: スレッドローカルな変更を管理.


## Clojure参照型 {#6849a2}


### Clojure: atom {#0bf80dd9-476b-48b3-a31c-17d9fb238318}

Clojureにおける **atom** は非協調的(Independent)で同期的(Syncronous)な変更を管理する.

atomの更新ではトランザクションは不要. **reset!** 関数を用いる.

**swap!** 関数は，atomを引数にとり更新した値を返す関数を適用するための関数.

```clojure
;; atomの宣言
(def foo (atom 0))

;; atomがbindされた.
foo

;; 参照先の値をリーダマクロ@で読む
@foo

;; 値の更新
(reset! foo 2)

;; 関数値の設定
(swap! foo (fn [_] (+ 1 1)))
```


### Clojure: ref {#98bcb478-d508-4490-ac92-5f81d13f2ea5}

Clojureにおける **ref** は協調的(Corrdinate)で同期的(Syncronous)な変更を管理する. つまり，複数の参照を同時に更新する.

[Software transactinal memory(STM)]({{< relref "20220116195030.md#2b37f626-bb5f-4c2c-bd7c-802134d9df87" >}}) をClojureで実現するためのシンタックス.

refで宣言した値を読むには **deref** をつかう. リーダマクロである **@** をつかって略記する.

参照先のオブジェクトを変更するには, **ref-set** or **alter** をつかう.

**commute** をつかうと, alterに順序保証ができる.


### Clojure: agent {#6af7597c-b0f6-4fcc-a6b3-4a7db9c064e5}

Clojureにおける **agent** は非協調的(Independent)で非同期的(Asyncronous)な変更を管理する.

リーダーマクロ **@** を利用して値を読む.

**send** メソッドを利用することで値を更新する. 正確には, send メソッドの引数でagentを更新するための関数値を与えると，Clojureはその処理をスレッドプールでの処理エンキューしてあとはClojureがよろしく実行してくれる.

**send-off** を利用すると, スレッドプールが必要に応じて動的に拡張されるのでわかりやすく言えばすぐに実行される.ファイル書き込みなどのようなBlocking I/O, １つの処理によってスレッドが止まってしまう場合に自動で別のスレッドが作られて実行される.

スレッドプールのスレッドをつかってClojureが暇なときに実行するため, いつagentの値が更新されたかわからない. 待ち合わせには **await** を利用する.

agentの値の更新化失敗すると，それ以後のagentの更新はできなくなる. フタをしてしまうようなもの. **agent-errors** に失内容が入っている. また **set-error-mode!** メソッドで **:continue** を指定すると続行することもできる.


### Clojure: deref {#463f6b2c-f02e-4d0b-9a48-76d696d6ce35}

as known as @ reader macro

状態の読み出しに利用できるリーダマクロだが, 何でも読める.atomだろうとrefだろうとagentだろう, futureもpromiseも.

[Clojure Threading Macros]({{< relref "20220116083656.md#508f51c6-37cb-4b61-9bce-91075f1f067e" >}}) だと [deref](https://clojuredocs.org/clojure.core/deref) を使うのかな？ best practiceがわからない.


## Clojure Concurrency Topics {#ebcec5}


### atomでのreset! とswap!の違い {#88423db9-b606-48ce-9a62-e6b3149d0514}

使い分けは単なる変数をセットするだけか, 今の情報を操作をしてupdateするか.

-   reset!は今の値に関わらず値をセットする.
-   swap!は今に関数を適用する.

とはいえ, reset!とswap!は互換性がある.

[Clojure Style Guide]({{< relref "20220313110515.md#3b44f8d5-e1ad-483a-81eb-6a61650baf64" >}}) には, **Prefer swap! over reset!** というルールもある.
とりあえず迷ったらswap!でよい.


### ClojureのSTMは使い物にならない {#b8c2d4}

深堀してないけど少し気になる問題.

[ClojureのSTMは使い物にならない – JUMPERZ.NET Blog](https://kanatoko.wordpress.com/2011/05/06/clojure_stm_too_slow/)


### 複数の状態を一度にupdateはrefと dosync {#650533}

はじめ, 状態の属性を複数持とうとした時, atomにMapをbindするのかと思ったが, そもそもrefとdosyncでupdateすればよいのだった.

refとdosyncはそもそもシングルスレッドでしか参照しない前提のときも使うものなのかな? 論理的には更新で矛盾が生じないのだけど.


### ⚖Clojure: atom/delay/future/promiseの比較 {#0cd352b6-a062-445a-bb00-dce7714f76ed}

いずれも同じ関数deref/@(reader macro)で読み出せるところがややこしい.

-   atom: メモリ共有
    -   スレッド内のメモリ共有の仕組みあり状態を扱う.
-   delay: 遅延評価
    -   **force or deref or @** をつかって評価してはじめて計算がはじまる.
-   future: バックグラウンド実行
    -   評価はバックグラウンド(i.e.別スレッド)で始まるが,
        その結果は参照してはじめてわかる
        (or まだ計算が終わってないかもということもわかる).
-   promise: バックグラウンド実行 + 遅延評価.
    -   promiseはfutureに似ている.
        -   どちらもバックグラウンド実行に対する参照を返す.
        -   futureは宣言時にプロシージャも宣言して即時実行.
        -   promiseは宣言時は参照に過ぎずdeleverで処理をあとからbindingする.
    -   promiseは値, futureは関数値のようなイメージ.
        -   どちらもバックグラウンド実行のためderefで結果を参照できる.

---

-   refs.
    -   [Clojureでの遅延評価関数(delay/force)]({{< relref "20220116094551.md#32a7e20b-78d2-41cd-b911-bd85865eac95" >}})
-   links
    -   [clojure future vs delay - Stack Overflow](https://stackoverflow.com/questions/28985818/clojure-future-vs-delay)
    -   [terminology - How do Clojure futures and promises differ? - Stack Overflow](https://stackoverflow.com/questions/4623536/how-do-clojure-futures-and-promises-differ)
    -   [Cuddly, Octo-Palm Tree: The Clojure Promise](https://cuddly-octo-palm-tree.com/posts/2021-11-14-clojure-promise/)


### 💡接続待機とpromise {#2fe182}

なるほどと思ったpromiseの使い方メモ.

<https://github.com/ejschoen/clj-socketio-client/blob/040f41e9a5465df7378ec0af5b87ae5bbc9cd782/src/clj_socketio_client/core.clj#L59>

clientからのwebsocketの接続処理で利用している. 呼び出し前でpromiseの値を作成して, callback関数の中でpromiseに対してdeliverをする. 呼び元の関数ではderefで待機する.

ここでやっていることは, promiseの値は非同期で動く真偽値のフラグであるが, callback関数でdeliverによって値がbindされるまではスレッドをブロッキングすることによって関数を即時リターンさせずにconnect完了したらリターンする.
