+++
title = "📝Clojure core.async"
lastmod = 2022-10-09T16:16:35+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Core]({{< relref "20220112142936.md" >}})
-   refs.
    -   [📝Clojure State and Concurrency]({{< relref "20220116191927.md" >}})
    -   [📝並行プログラミング]({{< relref "20220116195030.md" >}})
    -   [📝Clojure Transducer]({{< relref "20220331203002.md" >}})


## 📝Clojure: core.async {#a63165}

非同期プログラミングのためのClojureライブラリ.

<https://github.com/clojure/core.async>

理論としては[📝CSPモデル]({{< relref "20221008220000.md#8007a6cb-ec77-48c4-8dab-a14524ff57ef" >}})というものが使われている.


### Basic Concepts {#b3e95d}

-   チャネル(channel): 並列に動くタスク間で値を受け渡す通信路
    -   バッファを持ったキューのようなもの.
-   [軽量スレッド]({{< relref "20220116195030.md#0fbe2fc2-62bd-4c1c-8834-c6f211565542" >}})(協調スレッド)
    -   バッファsizeによってスレッドが切り替わる論理スレッド.
    -   切り替わりをパーク(parking)という.
    -   切り替わらないのをブロック(Blocking)という.


### Basic Syntax(API) {#c78c0b}

-   chan: channel生成
-   goマクロ: 非同期ブロック生成
    -   go-loop/recur: goとloop/recurの糖衣構文マクロ.
-   送信
    -   >!: channelに非同期で書く
    -   >!!: channelに同期で書く
-   受信
    -   <!: channelを非同期で読む
    -   <!!: channelを同期で読む
-   alts!: 複数チャネルから待ち受ける.


### バッファ制御 {#c9d66c}

bufferは有限サイズのキューのようなものなので, いっぱいになったときの制御を指定する必要がある.

-   dropping-buffer
    -   いっぱいになったら追加しようとした値を切捨て
-   sliding-buffer
    -   いっぱいになったら最初に追加した値を切捨て


## core.async Topics {#df3878}


### 💡core.asyncはGo LangのchannelのClojure版 {#a52a6f}

Goでいうchannelの概念らしいが, Go を知らないのでピンとこない.

ただ, Goと並行処理についての情報はClojureよりも検索で多くみつかる(とくに日本語)ので, 参考になる.

-   [Goでの並行処理を徹底解剖！](https://zenn.dev/hsaki/books/golang-concurrency)
    -   [並行処理と並列処理｜Goでの並行処理を徹底解剖！](https://zenn.dev/hsaki/books/golang-concurrency/viewer/term)
-   [Concurrency is not parallelism - The Go Programming Language](https://go.dev/blog/waza-talk)


### atomとchannelの関係 {#a2c4ae}


### agentとcore.asyncの関係 {#12b4a7}


## core.async Insights {#333324}


### 🤔producer-consumer patternとcore.async {#b2f50c}

わたしの拙い記憶だと, 非同期処理をJava やPythonでうまく処理するには, 同期キューを用いた[Producer-Consumer Pattern]({{< relref "20220116195030.md#1e0ae462-5cdf-45d2-82de-ef3587583ff1" >}})をつかうのが鉄板だが, それをcore.asyncをつかうことによってかんたんに実装できる(素晴らしい).

---

一応過去記事をみると共有メモリ方式ではなく[📝決定性データフローモデル]({{< relref "20221008195738.md" >}})?(忘れた).

-   refs
    -   [🖊Java で Producer-Consumer Pattern を実装してみた | Futurismo](https://futurismo.biz/archives/2656/)
    -   [🖊データフロー変数 (Oz) で実現する Producer-Consumer Pattern | Futurismo](https://futurismo.biz/archives/2829/)

---

2010年のまだ, core.asyncがなかった時代にblocking queueでchannelの概念を実装したという記事.

[Channels in Clojure · Dave Jack](https://www.vidston.com/post/channels-in-clojure/)


## 🔗Refenreces {#ec4e12}

-   [Mastering Concurrent Processes with core.async | Clojure for the Brave and True](https://www.braveclojure.com/core-async/)
-   [Clojure + core.async による非同期＆並列プロセスの世界 - 紙箱](https://boxofpapers.hatenablog.com/entry/core_async)
    -   [t_yano]({{< relref "20220216154041.md#9b47d9a7-ef98-4225-8f20-8ebd91001e11" >}})さんによる日本語によるわかりやすい説明記事.
-   [入門core.async](https://www.slideshare.net/sohta/coreasync)

わたしが愛読しているプログラミングClojure2版にはcore.asyncの話題は載ってない...


### Movies {#80662e}

-   ["Clojure core.async" by Rich Hickey (2013) - YouTube](https://www.youtube.com/watch?v=yJxFPoxqzWE)
    -   Rich Hickeyによるcore.asyncの紹介
-   [LispCast Clojure core.async: Channels - YouTube](https://www.youtube.com/watch?v=msv8Fvtd6YQ)
    -   [👨Eric Normand]({{< relref "20220324214106.md" >}})による謎の4分アニメーション動画.
-   [#17 大先輩Clojurianの矢野さん (@t_yano)にUzabase社やcore.asyncのディープな話をしてもらった #YCTFC #clojure - YouTube](https://www.youtube.com/watch?v=xQxio0uTDNA)
