+++
title = "📝Clojure フロー制御"
lastmod = 2022-08-24T10:43:01+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Language Spec]({{< relref "20220112142936.md" >}})
-   refs.
    -   [📝Clojure Logics]({{< relref "20220116081924.md" >}})
    -   [📝Clojure Exception]({{< relref "20220331055419.md" >}})
    -   [Clojure - Clojureを学ぼう - フロー制御](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/flow#_%E5%89%AF%E4%BD%9C%E7%94%A8%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97)

Clojureのフロー制御まとめ.


## Clojure Flow Basic Syntax {#02a52f53-0077-43b8-ba74-098c44004e17}

フロー制御の基礎シンタックス.

-   if
-   when

if-elseはないことに注意. condで代用する.


### 💡whenはifにelseがないことを示す {#86a039}

whenはifの簡易系だが, そのキモif文にelseがないことを示す.

概してifやelseの中身の()で囲まれるような部分が長くなりがちである. さらにifとelseがどこで区切れるのか可読性の問題もある.

そういう脳内メモリを節約するという目的がある.


### 💡Clojuse: switch文(cond/case) {#f7cde485-fda6-4c2f-8971-1158f0313c6b}

switchのシンタックスはないけどcondとcaseがある.

-   cond: <https://clojuredocs.org/clojure.core/cond>
    -   複数のifを書くときのわかりやすい記法.
    -   条件に当てはまらない場合の処理をelseで実施することができる.

<!--listend-->

```clojure
(defn pos-neg-or-zero[n]
  (cond
    (< n 0) "negative"
    (> n 0) "positive"
    :else "zero"))
```

-   case: <https://clojuredocs.org/clojure.core/case>
    -   condにおいて判定する値が１つしかない場合.
    -   case文の最後に条件なしを記述するとそれがdefaultになる.


### 🔎if-let/when-let は処理の結果による分岐でつかう {#cf8a7205-5993-4091-af92-a611dd48fd38}

if-let/when-letは, letで定義したロジック判定のシンボルをifでテストする.

これは，たとえば複雑な真偽判定のロジックにシンボルを割り当てることで可読性を上げるために利用できる.

---

if-letはマクロでありC言語の邪悪な習慣をエレガントにしたとか😕

なにかの処理をして戻り値がnilか否かで処理を分岐するときにエレガントな書き方ができる. 具体的にはlet とifで以下なものを,

```clojure
(let [result (proc)]
  (if result
    (do-something result)
    (do-else)))
```

if-letだと以下のようにかける.

```clojure
(if-let [result (proc)]
  ((do-something result)
    (do-else)))
```

Java的には関数を処理して異常の場合は戻り値に -1とかfalseとか戻さずに例外を上げるのがベストプラクティスだけど関数型でも同じなのだろうか？そしてこの 関数の呼び出し元に分岐を判断させるのがC言語の邪悪な習慣といっているのだろうか？いずれにしろこういう戻り値にnilをつかって呼び出し元を困らせる邪悪な関数につかう.

ref. [💡例外がないと戻り値チェックでウンコード]({{< relref "20220305075933.md#42fcb06a-99f6-4cd0-99f2-186c251bc13d" >}})

まあif-letやwhen-letはnilが戻るような副作用のある関数の呼び出しの文脈で利用するものと心得ておこう.

see more. [if-let or throw pattern on http request]({{< relref "20220209102028.md#bc9bff86-bb2c-476f-97b1-9edf59460c14" >}})


## Clojure:副作用の繰り返し(dotimes/doseq/for) {#f049f947-ed63-4ae2-b073-5c9150cf60b3}

[Clojure - Clojureを学ぼう - フロー制御](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/flow#_%E5%89%AF%E4%BD%9C%E7%94%A8%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97)

-   dotimes
    -   式n回評価, nilを返す.
-   doseq
    -   シーケンスに対して順列に繰り返す.
    -   遅延シーケンスは評価を強制.
    -   nilを返す.
    -   複数のシーケンスに対しはforEachのように振る舞う.
-   for
    -   [リスト内包表記 | List Comprehensions]({{< relref "20220305080412.md#86a37ede-8969-458b-945d-a72214ec1c1a" >}}).
    -   ジェネレータ関数.


### 💡Clojureの繰り返し: map vs doseq(for) {#cb2449fb-2bed-4b5d-8633-5ce00723f7fa}

どちらもシーケンスに対する処理を実施する.

副作用があるときにdoseq(for)を利用する, そうでないときにmapを利用する.

なるべく副作用がないようにプログラミングを構築するというClojureの考えとしてはdoseqよりもmapのほうが登場回数が多い.

mapは関数をすぐには適用せずに遅延シーケンスを構築する. 実際に中の値の評価をするにはdoall, intoなどの方法が必要.

```clojure
(doall (map coll))
(into [] (map coll))
(into-array (map coll))
```

---

リスト内包表記(for)はmap/filterよりもhuman-readableという利点はある. 以下は同じである.

```clojure
(for [number [1 2 3]] (* number 2))
(map #(* % 2) [1 2 3])
```

シンプルな変換処理を有限なリストに適用するならばmap/filterよりもみやすいかもしれない(Pythonではmap/filterよりもリスト内包表記がよくつかわれる).

ひとつのシーケンスに複数の変化を施すならば遅延シーケンスを扱うmapに利点がある. 複数のシーケンスを順番に従って取り出して扱うならばforのほうが読みやすい(cf. mapcat, juxt).

---

-   refs.
    -   [Clojure Map(clojure.core.map)]({{< relref "20220116080205.md#30a935ff-4448-43a2-8ec7-8c37e18b6ca5" >}})
    -   [Map vs For - Google Group](https://groups.google.com/g/clojure/c/UH3VynMwPic)
    -   [List Comprehension · Practicalli Clojure](https://practical.li/clojure/thinking-functionally/list-comprehension.html)


## Clojure: Threading Macros {#508f51c6-37cb-4b61-9bce-91075f1f067e}

-   スレッディングマクロ.
-   基本的には **->** と **->>** をつかう.
-   入れ子構造の関数呼び出しを逐次処理な呼び出しに変える.

refs:

-   [clojure.org - Threading Macros Guide](https://clojure.org/guides/threading_macros)
-   [スレッドマクロを整理する - 紙箱](https://boxofpapers.hatenablog.com/entry/threading_macros)


### thread-first (->) と thread-last (->>) {#8df000}

-> も ->>も1つ目のフォームを初期値にして2つ目のフォームから逐次適用していく.

->はフォームの第一引数に引数が入る. 一方, ->>は最終引数に引数が入る.

->> 利用するケースは第一引数に高階関数を受取り末尾にリストを受け取るような関数である.(map, filter, reduce...)

see also: [💡Clojureデータ構造の操作関数の分類]({{< relref "20220116080205.md#582983e0-0ed8-419e-aa14-c9b227ad42f9" >}})


### as-> clojure thread-firstとthead-lastを混在させる {#f8bc06}

thread-as or as->をつかうことで, 混在させられる.

```clojure
(-> [10 11]
    (conj 12)
    (as-> xs (map - xs [3 2 1]))
    (reverse))
; (11 9 7)
```


### cond-> 条件つきスレッドマクロ {#edc8041c-a7eb-4b51-8433-f8b1038b3ffc}

cond->は初期値と(条件, 処理)のリストを受ける. 条件が真のときのみ処理はされる.

```clojure
(cond-> (初期値)
  (条件) (処理)
  (条件) (処理)
  (条件) (処理))
```

もし存在すれば(if-exists)そのデータを初期値に加えるようなときにつかう. 初期値がcollectionで, もしparamが存在すればそれをcollectionにaddやassocやconjみたいなケースでよく見かける.

[条件付きMap操作: assoc-if/update-if 追加する値がnilでなければ操作]({{< relref "20220302101805.md#659c997d-8c8e-4837-a8b3-a60cc77082c4" >}})


### some->/some->> : 副作用のある呼び出しを中断 {#83a26d9b-05ee-4e0f-b052-49f701755297}

ref. [some-> - Threading Macros Guide](https://clojure.org/guides/threading_macros#_some_some_and_cond)

Threadingマクロの途中で副作用のあるJavaの関数(往々にして戻り値がない, つまりnullを返す可能性がある)を呼び出す時, 途中結果がnullならばその後の処理を打ち切る用途としてsome->というスレッディングマクロがある.


### Emacs clojure-mode: M-x clojure-thread {#f4cff6}

Emacs clojure-modeの threadingリファクタリングサポート.

ref: <https://github.com/clojure-emacs/clojure-mode/#refactoring-support>

-   clojure-unwind/clojure-unwind-all:
    -   threading expressionを解く.
-   clojure-thread-first-all: -> へ変換.
-   clojure-thread-last-all: ->> へ変換.

threading macrosを理解するには,
->> の内側で M-x clojure-unwind-allを叩くとスレッディングマクロを使わない場合に変換される. もとに戻すには, M-x clojure-thread-last-all.


### 💡memo: Clojure Threading MacrosはR-langのdplyrのpipe記法に似ている {#86f044}

これは 羽鳥教のdplyrに似てないか？

ref:

-   [羽鳥教のすゝめ ～dplyr編～ | kitayama lab](https://kitayamalab.wordpress.com/2016/05/16/%E7%BE%BD%E9%B3%A5%E6%95%99%E3%81%AE%E3%81%99%E3%82%9D%E3%82%81-%EF%BD%9Edplyr%E7%B7%A8%EF%BD%9E/)
-   [羽鳥教入信のすゝめ - Qiita](https://qiita.com/uri/items/a66b682507181baa0d50)

そしてこの記法の強力な魅力がデータ分析においてR言語をPythonよりも好む人がいるように, Clojureにおいても大変魅力的に違いない.


### 💡memo: threadingとはわたしである {#7e644b}

theading = 糸, 筋道. これはつまり, わたしではないか？

ref: [🎓経道とはThreadである]({{< relref "20220209051354.md" >}})


## Active Recalls {#b27a23}


### Clojureにおけるif-letとはなんですか？またその目的はなんですか？ {#0c58f9}

letで定義した真偽値をifで評価する.

複雑なロジックにシンボルを割り当てることで可読性を上げるため.


### Clojureで複数のifをするときのシンタックスシュガーはなんですか？ {#8dcaee}

cond, case.


### Clojureで副作用がある繰り返しの３つのシンタックスなんですか？また戻り値はなんですか？ {#bb329e}

dotimes, doseq, for.

戻り値はnil.
