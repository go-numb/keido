+++
title = "📝Clojure Flows"
lastmod = 2022-09-11T22:14:15+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Language Spec]({{< relref "20220112142936.md" >}})
-   refs.
    -   [📝Clojure Logics]({{< relref "20220116081924.md" >}})
    -   [📝Clojure Exception]({{< relref "20220331055419.md" >}})
    -   [📁Clojure Expression Problem]({{< relref "20220307162746.md" >}})
-   links
    -   [Clojure - Clojureを学ぼう - フロー制御](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/flow#_%E5%89%AF%E4%BD%9C%E7%94%A8%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97)


## Overview {#3b8782}

Clojureのフロー制御まとめ.

フロー制御を条件分岐とシーケンス処理の２つに分解すると, このメモでは条件分岐をあつかう. シーケンス制御は[📝Clojure Logics]({{< relref "20220116081924.md" >}})で扱う.

また条件分岐の発展である[📝Clojure マルチメソッド]({{< relref "20220506155825.md" >}})と[📝Clojure: Protocols]({{< relref "20220517114759.md" >}})はそれぞれ別メモで扱う.


## Clojure条件分岐(if/when) {#02a52f53-0077-43b8-ba74-098c44004e17}

Clojure条件分岐の基礎.


### Clojure: if/when {#bc18f6}

-   if
-   when
-   if-not
-   when-not
-   if-let
-   when-let

if-elseはないことに注意. condで代用する.


### Clojure: switch文(cond/case) {#f7cde485-fda6-4c2f-8971-1158f0313c6b}

switchのシンタックスはないけどcondとcaseがある.

このswitch文の発展が[📝Clojure マルチメソッド | Multimethod]({{< relref "20220506155825.md" >}}).

-   cond: <https://clojuredocs.org/clojure.core/cond>
    -   複数のifを書くときのわかりやすい記法.
    -   条件に当てはまらない場合の処理をelseで実施することができる.

<!--listend-->

```clojure
(defn pos-neg-or-zero[n]
  (cond
    (< n 0) "negative"
    (> n 0) "positive"
    :else "zero"))
```

-   case: <https://clojuredocs.org/clojure.core/case>
    -   condにおいて判定する値が１つしかない場合.
    -   case文の最後に条件なしを記述するとそれがdefaultになる.


## Clojure フロー制御トピックス {#ef894b}


### andとorをフロー制御につかう {#3de6f0}

[💡LISPの世界のand/orはフロー制御の評価器]({{< relref "20220116081924.md#405a42c1-b9b5-4e84-bf8c-d151623921d7" >}})


### 💡whenはifにelseがないことを示す {#86a039}

whenはifの簡易系だが, そのキモif文にelseがないことを示す.

概してifやelseの中身の()で囲まれるような部分が長くなりがちである. さらにifとelseがどこで区切れるのか可読性の問題もある.

そういう脳内メモリを節約するという目的がある.


### 💡if-let/when-let は処理の結果による分岐でつかう {#cf8a7205-5993-4091-af92-a611dd48fd38}

if-let/when-letは, letで定義したロジック判定のシンボルをifでテストする.

これは，たとえば複雑な真偽判定のロジックにシンボルを割り当てることで可読性を上げるために利用できる.

---

if-letはマクロでありC言語の邪悪な習慣をエレガントにしたとか😕

なにかの処理をして戻り値がnilか否かで処理を分岐するときにエレガントな書き方ができる. 具体的にはlet とifで以下なものを,

```clojure
(let [result (proc)]
  (if result
    (do-something result)
    (do-else)))
```

if-letだと以下のようにかける.

```clojure
(if-let [result (proc)]
  ((do-something result)
    (do-else)))
```

Java的には関数を処理して異常の場合は戻り値に -1とかfalseとか戻さずに例外を上げるのがベストプラクティスだけど関数型でも同じなのだろうか？そしてこの 関数の呼び出し元に分岐を判断させるのがC言語の邪悪な習慣といっているのだろうか？いずれにしろこういう戻り値にnilをつかって呼び出し元を困らせる邪悪な関数につかう.

ref. [💡例外がないと戻り値チェックでウンコード]({{< relref "20220305075933.md#42fcb06a-99f6-4cd0-99f2-186c251bc13d" >}})

まあif-letやwhen-letはnilが戻るような副作用のある関数の呼び出しの文脈で利用するものと心得ておこう.

see more. [if-let or throw pattern on http request]({{< relref "20220209102028.md#bc9bff86-bb2c-476f-97b1-9edf59460c14" >}})
