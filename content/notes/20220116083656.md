+++
title = "📝Clojure Flows"
tags = ["WIKI"]
draft = false
+++

-   refs:
    -   [📝Clojure Logics]({{< relref "20220116081924.md" >}}) [📂Clojure Language Spec]({{< relref "20220112142936.md" >}})
    -   [Clojure - Clojureを学ぼう - フロー制御](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/flow#_%E5%89%AF%E4%BD%9C%E7%94%A8%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97)


## Clojure Flow Basics {#clojure-flow-basics}

Clojureのフロー制御まとめ.

-   if
-   when
    -   true判定.
-   if-let
    -   letで定義したロジック判定のシンボルをifでテストする.
    -   これは，たとえば複雑な真偽判定のロジックにシンポルを割り当てることで可読性を上げるために利用できる.
    -   when-letもある.
-   cond
    -   複数のifを書くときのわかりやすい記法.
    -   条件に当てはまらない場合の処理をelseで実施することができる.
-   case
    -   condにおいて判定する値が１つしかない場合.


## Clojure:副作用の繰り返し(dotimes/doseq/for) {#clojure-副作用の繰り返し--dotimes-doseq-for}

[Clojure - Clojureを学ぼう - フロー制御](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/flow#_%E5%89%AF%E4%BD%9C%E7%94%A8%E3%81%AE%E3%81%9F%E3%82%81%E3%81%AE%E7%B9%B0%E3%82%8A%E8%BF%94%E3%81%97)

-   dotimes
    -   式n回評価, nilを返す.
-   doseq
    -   シーケンスに対して順列に繰り返す.
    -   遅延シーケンスは評価を強制.
    -   nilを返す.
    -   複数のシーケンスに対しはforEachのように振る舞う.
-   for
    -   リスト内包表記.
    -   ジェネレータ関数.


## Clojure Exception: 例外 {#clojure-exception-例外}

-   Javaのようにtry/catch/finallyが利用できる.
-   throwシンタックスで例外を引数にとり連外を発生させる.
    -   例外はJavaのクラスで作成できる(Exception. )
    -   Clojureの記法でex-infoはmessageとmapを受取リ例外を発生させる.
    -   Clojureの記法でex-dataはex-infoで入力したmapを展開する.


## Clojureの繰り返し: map vs doseq {#clojureの繰り返し-map-vs-doseq}

どちらもシーケンスに対する処理を実施する.

副作用があるときにdoseq(for)を利用する, そうでないときにmapを利用する.

なるべく副作用がないようにプログラミングを構築するというClojureの考えとしては
doseqよりもmapのほうが登場回数が多い.

mapは関数をすぐには適用せずに遅延シーケンスを構築する. 実際に中の値の評価をするにはdoall, intoなどの方法が必要.

```clojure
(doall (map coll))
(into [] (map coll))
(into-array (map coll))
```

-   refs.
    -   [Clojure Map(clojure.core.map)]({{< relref "20220116080205.md#clojure-map--clojure-dot-core-dot-map" >}})
    -   [Clojure:副作用の繰り返し(dotimes/doseq/for)](#clojure-副作用の繰り返し--dotimes-doseq-for)


## Active Recalls {#active-recalls}


### Clojureにおけるif-letとはなんですか？またその目的はなんですか？ {#clojureにおけるif-letとはなんですか-またその目的はなんですか}

letで定義した真偽値をifで評価する.

複雑なロジックにシンボルを割り当てることで可読性を上げるため.


### Clojureで複数のifをするときのシンタックスシュガーはなんですか？ {#clojureで複数のifをするときのシンタックスシュガーはなんですか}

cond, case.
