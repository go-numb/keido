+++
title = "📝Clojure Collections and Sequences"
lastmod = 2022-09-11T21:40:31+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Core]({{< relref "20220112142936.md" >}})
-   refs:
    -   [📝Clojure Idioms]({{< relref "20220302101805.md" >}})
    -   [📝Clojure Functional Programming]({{< relref "20220116094551.md" >}})

Clojureのシーケンスや高階関数を巧みに扱うことができるとモテるとか. こういうのは知っているか知らないかなのでイディオムを覚えてモテよう.


## Clojure: Collections {#310e6c}

ClojureのCollectionはimmutableでpersistent.

---

-   refs
    -   [📝immutable]({{< relref "20220114074914.md#fbc351d5-b1d2-4dcd-95cd-9d5021f88565" >}})
    -   [📝persistent]({{< relref "20220114074914.md#7e585ab7-a40f-4a1e-aeaa-812eb632f2ff" >}})
    -   [イミュータブル時代の言語としてのClojure - Qiita](https://qiita.com/kawasima/items/c695e2f4ee079a6debf5)


### Clojure Collection操作 {#c18572}

よく使うものを列挙.

-   conj: コレクションの結合. 他の言語ではpush, concat, appendとか.


## Clojure Sequences(clojure.core.sequence) {#648d4030-475a-4dca-a0d9-5a6defcae18a}

refs: [Clojure - Clojureを学ぼう - シーケンシャルなコレクション](https://japan-clojurians.github.io/clojure-site-ja/guides/learn/sequential_colls)

シーケンス型 には4種類の重要なデータ構造がある.

-   list: ()
-   vector: []
-   map: {}
-   set: #{}

[🔖List]({{< relref "20220310124045.md#aaef8de1-331f-431a-a5f4-39063b81f73d" >}})


### Clojure: into {#aec02797-3c3f-407e-95df-67073fa71b54}

into は第一引数のコレクションに, 第二引数のシーケンスの要素全てを, 元のコレクションにとって自然な形で追加 (conj) してくれる関数.

(into %1 %2) は,

(reduce conj %1 %2) つまり %1 に %2 の要素を順に conj したものと同等.

(conj (conj %1 %2の最初の要素) %2の二番目の要素)と同等.


### 💡Clojure contains?の罠 {#15121a4d-3f9f-4294-a7ec-b025373adfc3}

この値がリストに含まれるかどうかを判定するとき, Clojureのcontains?がつかえないので紛らわしいという話題.

[contains? - clojure.core](https://clojuredocs.org/clojure.core/contains_q)

これはMapにkeyが含まれるかを判定する関数でリストに対してつかっても期待通りの結果にならない...

この場合, someだったりJavaの.contains methodをつかう.

```clojure
(defn in?
  "true if coll contains elm"
  [coll elm]
  (some #(= elm %) coll))

(.contains [100 101 102] 101)
```

ref. [data structures - Test whether a list contains a specific value in Clojure - Stack Overflow](https://stackoverflow.com/questions/3249334/test-whether-a-list-contains-a-specific-value-in-clojure)

---

文字列はこっち. [文字列を含むか？: clojure.core/includes?]({{< relref "20220428163355.md#ecab6dfc-90f5-4deb-b675-5a14420c8803" >}})


### 💡ClojureでSliding window Algorithm {#55f4d3e9-7dad-4832-a284-a3f204207903}

[Sliding Window Algorithm]({{< relref "20220830152735.md#b07ffa38-60b1-4ae2-b130-d924e59f8ccb" >}})をClojureでimplする方法.

-   [clojure - Sliding window over seq - Stack Overflow](https://stackoverflow.com/questions/1427894/sliding-window-over-seq)


### 💡ClojureでFIFOキューを扱う {#c9d8db5f-1b0c-4cd7-ba8e-cdb54b9170df}

Clojure.lang.PersistentQueueという隠し機能かあるらしい.

Clojure.lang.PersistentQueue/EMPTYが空キューを示す.

conj/pop/peekで操作. 閲覧はseqで変換する.

---

有限のキューなら以下の実装でいける.

```clojure
(defn push [v i n]
  (if (>= (count v) n) (conj (subvec v 1 n) i) (conj v i) ))
```

ref. [queue - Fixed length stack structure in Clojure - Stack Overflow](https://stackoverflow.com/questions/13353463/fixed-length-stack-structure-in-clojure)

---

-   [🔖queue]({{< relref "20220310124045.md#c7e19204-6111-4559-8978-cd93049cf076" >}})
-   [Queues in Clojure – Michael Zavarella – I don't edit anything I write](https://admay.github.io/queues-in-clojure/)
-   [スタックとキュー - tnoda-clojure](https://tnoda-clojure.tumblr.com/post/25798318986/stack-and-queue-in-clojure)


### <span class="org-todo todo _">💡</span> listのマージ {#05fccf}

listに対してmergeをすると期待通りにならない罠がある.

```clojure
(merge '(1 2 3) '(4 5 6))
;; => ((4 5 6) 1 2 3)
```

この場合, **concat** を利用する. 戻り値はLazu Seqになることに注意(input がvectorでもseq).


## Clojure Map(clojure.core.map) {#30a935ff-4448-43a2-8ec7-8c37e18b6ca5}

-   assoc: (key, value)の追加
-   dissoc: (key, value)の削除
-   update: (key)の指す(value)に引数で与えられた関数を適用して置き換える.
-   merge: (key, value)の集合の追加

assocは値を更新してMapを返す, updateは値に関数を適用してMapに束縛する. この関係は, [atomでのreset! とswap!の違い]({{< relref "20220116191927.md#88423db9-b606-48ce-9a62-e6b3149d0514" >}}) に似ている.

mapは遅延シーケンスを構築するため, doall などの評価は別途必要.

しかしdoallを一連のmap/filter/reduce中に挟むと処理速度が落ちるため必要なときのみ利用する. または逐次処理であるdoseqを検討する.

途中で中身が必要というのはそもそもmapを命令形のfor文のノリで使っている可能性が高い.

-   cf. [Clojureの繰り返し: map vs doseq]({{< relref "20220116083656.md#cb2449fb-2bed-4b5d-8633-5ce00723f7fa" >}})
-   ref. [Clojure: 遅延評価/遅延シーケンス]({{< relref "20220116094551.md#4f51982f-85bd-4e92-a85e-12cf66360653" >}})


## ClojureにおけるSequenceとCollectionの違い {#86f363}

ClojureではCollectionとSequenceは異なる概念.

-   collection: データ構造の抽象.
-   sequence: collectionの中でデータを順次アクセス可能(シーカブル)なもの.

SequenceはCollectionの特殊な形態であり、Collectionを表現する方法の1つ.

実装レベルでは coll?で真が変えればcollection, seq?で真が変えればsequence.

collectionはIPersistentCollectionというインタフェースを実装しているもの.
IPersistentCollectionは5つのメソッド（count, cons, empty, equiv, seq）からなる.

sequenceはISeqというインタフェースを実装しているもの.
ISeqは(first, next, more, cons)からなる.

---

-   ref: Clojureにおけるデータ構造の抽象化を理解して独自のデータ構造を実装する
    -   [Part 1: Collectionとは何か - 本当は怖いHPC](https://freak-da.hatenablog.com/entry/2015/08/05/222224)
    -   [Part 2: Sequenceとは何か - 本当は怖いHPC](https://freak-da.hatenablog.com/entry/2015/08/11/180047)


### 💡Clojureデータ構造の操作関数の分類 {#582983e0-0ed8-419e-aa14-c9b227ad42f9}

Clojureの関数は大きく分けて２つの種類に分けられる.

-   データ構造の操作の関数(conj, disj, assoc, dissoc...)
-   シーケンス操作の関数(cons, map, filter, reduce..)

データ構造を操作する関数は関数の次にデータ構造を受ける.
一方シーケンス操作は関数評価式の最後にデータ構造を受ける.

[Clojure: Threading Macros]({{< relref "20220116081924.md#508f51c6-37cb-4b61-9bce-91075f1f067e" >}}) にも 2種類あるのもこれが関係している.

ref: [Clojure - Frequently Asked Questions](https://clojure.org/guides/faq#seqs_vs_colls)


### Associative vs Sequencialという概念の対立 {#524f01}

T.B.D.


## 🔗References {#3b90d2}


### externals {#0bf849}

-   [Clojureのsequence関係のユーティリティ関数のまとめ · GitHub](https://gist.github.com/syou6162/3648601)
