+++
title = "📝Clojure Web Development"
tags = ["WIKI"]
draft = false
+++

ClojureによるWeb開発ノウハウまとめ.

tags: [🏷Clojure]({{< relref "20211111225741.md" >}}) [🏷Web Development]({{< relref "20220220094636.md" >}})

テーマが大きいので分割するかも.

-   API Server はこちら: [📝Clojure API Server Development]({{< relref "20220226220442.md" >}})
-   API Client はこちら: [📝Clojure API Client Development]({{< relref "20220209102028.md" >}})


## Clojure Web Development概論 {#clojure-web-development概論}

ClojureではRailsやDjangoのようなデファクトスタンダードな
Webフレームワークをつかうよりも 小さなライブラリを組み合わせて開発することが多い.

そのため機能ごとにいろんなライブラリが存在する.


## Clojure: Web Frameworks {#clojure-web-frameworks}

-   Luminus
-   [Duct]({{< relref "20220211142329.md#clojure-backend-framework" >}}) (正確には状態管理ライブラリ + モジュール作成テンプレート).

ref: [🏷Web Framework]({{< relref "20220220095102.md#web-application-framework" >}})


## Clojure: Ring - Webサーバ抽象 {#clojure-ring-webサーバ抽象}

<https://github.com/ring-clojure/ring>

ClojureにおけるWeb Server Abstructionのデファクトスタンダード.

-   [Why Use Ring? · ring-clojure/ring Wiki · GitHub](https://github.com/ring-clojure/ring/wiki/Why-Use-Ring%3F)
    -   なぜRingをつかうのか？
        -   WebアプリをClojureの関数とMapデータのみで構築するという設計概念を示す.
        -   Java servletの上で走るアプリにコンパイルする.
-   4つのコンポーネントからなる([ref](https://github.com/ring-clojure/ring/wiki/)).
    -   Handler
        -   Clojureの関数で表現される.
        -   Request Mapを受取り, Response Mapを返す.
    -   Request
    -   Response
    -   Middleware

ref: [🏷Web Server Abstruction]({{< relref "20220220095102.md#web-server-abstruction" >}}) [📝Clojure: Pedestal]({{< relref "20220226220442.md#clojure-pedestal" >}})


### ring: middleware {#ring-middleware}

お役立ちmiddlewareをまとめていく.

-   [ring](https://github.com/ring-clojure/ring/tree/master/ring-core/src/ring/middleware)
    -   wrap-params(ring.middleware.params)
        -   ringはデフォルトではrequestに付随するパラメータに対してなにもしない.
            wrap-paramsを利用すると パラメータを処理してくれる.
            -   (通常getからの) urlについたquery-paramsを :query-paramsにbind.
            -   (通常postからの) bodyの中のform-paramsを :form-paramsにbind.
            -   :query-paramsと :form-paramsのデータを :paramsにマージ. そのため大抵は
                :paramsをチェックすればデータが入っている.
    -   wrap-keyword-params(ring.middleware.keyword-params)
        -   ring は request-mapのkeyをdefaultではstringとして扱う.これをkeywordに変換する.
        -   wrap-json-paramsの:json-paramsは ring parameter mapである :paramsにマージされる. しかしring paramsは mapのkeyがkeywordではなくstringとして扱うため wrap-keyword-params との併用が必要.
-   [ring-json](https://github.com/ring-clojure/ring-json)(ring.middleware.json)
    -   wrap-json-response
        -   response-mapのbodyのColojure MapやVectorをplain/textのJSONに変換.
    -   wrap-json-body
        -   request-mapのbodyのjson形式の文字列をclojure collectionに変換して :bodyにbinding.
    -   wrap-json-params
        -   request-mapの bodyの json形式の文字列を Mapに変換して(:bodyではなく)
            :json-paramsにbinding.


### tips: run-jettyにhandlerのvarを渡してhot reloading {#tips-run-jettyにhandlerのvarを渡してhot-reloading}

varは リーダマクロ **#'** にて取得できる. すなわち,

```clojure
(run-jetty #'handler {:port 3000})
```

詳しくは以下を参照.

-   [Column: REPL 駆動開発を取り入れて Ring でもう少し遊んでみる — Clojure の日本語ガイド](http://ayato-p.github.io/clojure-beginner/intro_web_development/column_rdd_and_more_ring.html)
-   [何故、RingハンドラーにVarを渡すと、ハンドラーを書き換えても書き換えたハンドラーが呼び出されるのか - ayato-p](https://scrapbox.io/ayato-p/%E4%BD%95%E6%95%85%E3%80%81Ring%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%83%BC%E3%81%ABVar%E3%82%92%E6%B8%A1%E3%81%99%E3%81%A8%E3%80%81%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%83%BC%E3%82%92%E6%9B%B8%E3%81%8D%E6%8F%9B%E3%81%88%E3%81%A6%E3%82%82%E6%9B%B8%E3%81%8D%E6%8F%9B%E3%81%88%E3%81%9F%E3%83%8F%E3%83%B3%E3%83%89%E3%83%A9%E3%83%BC%E3%81%8C%E5%91%BC%E3%81%B3%E5%87%BA%E3%81%95%E3%82%8C%E3%82%8B%E3%81%AE%E3%81%8B)

varというのが参照型のため実際を差し替えられる.

-   refs
    -   [Clojure: clojure.lang.Var]({{< relref "20220116080418.md#clojure-defとvarとsymbol" >}})
    -   [💡 def macro / alter-var-rootによるvarの再定義]({{< relref "20220116080418.md#clojure-defとvarとsymbol" >}})
    -   [Reloaded Workflow]({{< relref "20220117205249.md#reloaded-workflow" >}})


### References {#references}

-   [clojure-ring - 開発者ドキュメント](https://ja.getdocs.org/clojure-ring/)
-   [Part2: Ring について知る — Clojure の日本語ガイド](https://ayato-p.github.io/clojure-beginner/intro_web_development/part2_what_is_ring.html)
    -   あやとぴさんのWeb 開発チュートリアル.
-   [ClojureのWeb開発でもっとも重要なRing Handlerについて理解する - TOYOKUMO](https://tech.toyokumo.co.jp/entry/2019/07/03/122656)
-   [Clojure Ring Middleware大全 - TOYOKUMO Tech Blog](https://tech.toyokumo.co.jp/entry/2019/12/26/174006)
    -   トヨクモの新卒やアルバイト学生のための教育用Ring解説記事.


### Active Recalls {#active-recalls}


#### Clojure RingのようなWebアプリを構築するための仕組みを一般的になんといいますか？ {#clojure-ringのようなwebアプリを構築するための仕組みを一般的になんといいますか}

Webサーバ抽象, Web Server Abstruction.

Web Serverと Web アプリがやり取りをするための仕様.


#### Clojure Ring における4つのコンポーネントはなんですか？ {#clojure-ring-における4つのコンポーネントはなんですか}

ハンドラー, ミドルウェア, リクエストマップ, レスポンスマップ.


## Heroku with Clojure {#heroku-with-clojure}

-   <https://devcenter.heroku.com/articles/deploying-clojure>
    -   ja: <https://devcenter.heroku.com/ja/articles/deploying-clojure>
-   <https://devcenter.heroku.com/articles/getting-started-with-clojure>
    -   ja: <https://devcenter.heroku.com/ja/articles/getting-started-with-clojure>
-   <https://devcenter.heroku.com/articles/clojure-support>
    -   ja: <https://devcenter.heroku.com/ja/articles/clojure-support>

leiningenの作者がHerokuで働いてたらしくドキュメントがていねいとか.

<https://twitter.com/as_chapa/status/1198104444711256064>
<https://twitter.com/iku000888/status/1099293410693808128>


### tip: Heroku上のappにreplで接続 {#tip-heroku上のappにreplで接続}

heroku run lein replでHerokuサーバ上でreplを起動できる.

&gt; heroku run lein repl


### howto: Heroku Deployでlein deps失敗の対処方法 {#howto-heroku-deployでlein-deps失敗の対処方法}

&gt; Leiningen 1.7.1 がデフォルトで使用されますが、project.clj に :min-lein-version
"2.0.0"​ がある場合は (強く推奨されます)、Leiningen 2.9.1 リリースが代わりに使用されます。

これにハマった. project.cljに :min-lein-version "2.0.0" を記載して解決✨

ref: <https://devcenter.heroku.com/ja/articles/clojure-support>


### howto: Heroku上で Botを動かそうとするとエラー {#howto-heroku上で-botを動かそうとするとエラー}

web appではなく worker appにする必要がある.

そうしないと 60secでBootTimeoutとして扱われてProcess Killされる.

```text
2022-02-11T09:30:12.486217+00:00 heroku[web.1]: Error R10 (Boot timeout) -> Web process failed to bind to $PORT within 60 seconds of launch
2022-02-11T09:30:12.581863+00:00 heroku[web.1]: Stopping process with SIGKILL
2022-02-11T09:30:12.834345+00:00 heroku[web.1]: Process exited with status 137
2022-02-11T09:30:13.225734+00:00 heroku[web.1]: State changed from starting to crashed
```

Procfileを新規作成して以下を記載.

&gt; worker: lein run

heroku cliより

&gt; heroku ps:scale worker=1

ただし workerは30分活動がないとsleepしてしまう.

実際はheroku schedulerの活用も検討.


### howto: tools.deps管理のプロジェクトをHerokuにデプロイ {#howto-tools-dot-deps管理のプロジェクトをherokuにデプロイ}

未実施だけどブックマーク. leiningenの作者はライバルにいじわる？

ref: [試行錯誤な日々: clojure cliプロジェクトをherokuで動かす](https://asukiaaa.blogspot.com/2022/03/clojure-cli-on-heroku.html)


## Firebase/Google Cloud w/ Clojure {#firebase-google-cloud-w-clojure}

[🏷Firebase]({{< relref "20220215183442.md" >}})

ref: <https://github.com/tsu-nera/meigen-bot-firebase-clj>


## Firebase Firestore(aka. Google Cloud Firestore)  w/ Clojure {#firebase-firestore--aka-dot-google-cloud-firestore--w-clojure}

せっかくのClojureなのでClojure onlyで頑張らずにJavaやnode.jsの資産を活用する方向がいいかな...Java資産活用しないとリッチーヒッキーの開発モチベに反する🤔

-   [Add the Firebase Admin SDK to your server  |  Firebase Documentation](https://firebase.google.com/docs/admin/setup/)
-   [Get started with Cloud Firestore  |  Firebase Documentation](https://firebase.google.com/docs/firestore/quickstart)


### 💡Firestoreのスキーマレスのメリットとclojure.specの思想が反する {#firestoreのスキーマレスのメリットとclojure-dot-specの思想が反する}

Firestoreは[スキーマレスDB]({{< relref "20220311163333.md#nosqlの特徴" >}})ということを留意する.

すなわちこの特性によりスキーマ設計が不要というメリットを活かすならば動的言語であるClojureとの 相性がよく
JSON Schema(Shcema/Malli/clojure.spce)は不要かもしれない.

ref. [📝Clojure spec]({{< relref "20220323030746.md" >}})


### 💡FirestoreのドキュメントデータベースパラダイムとClojureプロトコルの思想が反する {#firestoreのドキュメントデータベースパラダイムとclojureプロトコルの思想が反する}

またFirestoreは [ドキュメントデータベース]({{< relref "20220311163333.md#ドキュメントデータベース" >}})ということも注意.

ドキュメントのモデルを作成してプロトコルを定義する必要はあるのか？

なぜならばドキュメントはコレクションに格納されてその範囲内でのみシーケンス処理される. プロトコルとは操作抽象であり異なるデータ型を同一IFでシーケンシャルに処理することが目的であるがそもそもドキュメントデータベースのパラダイムにおいては異なるドキュメントを同一コレクションに入れるのかという問題がある.

ref: [📝Firebase Firestore]({{< relref "20220311153829.md" >}}) [defprotocol]({{< relref "20220307162746.md#プロトコル--protocols" >}})


## Firebase Functions(aka. Google Cloud Functions) w/ Clojure {#firebase-functions--aka-dot-google-cloud-functions--w-clojure}

ClojureScriptを利用してJavaScript(Node.js)のライブラリを使うのがよい.

-   [ClojureScript + Firebase - DEV Community](https://dev.to/kbaba1001/clojurescript-firebase-3a26)
    -   ref: <https://twitter.com/kbaba1001/status/1342628846655324160>
-   [My PWA made with Clojure/ClojureScript exceeded 400 users 🎉 - DEV Community](https://dev.to/boxp/my-pwa-made-with-clojure-clojurescript-exceeded-400-users-5co7)
    -   ref: <https://twitter.com/b0xp2/status/1259685025122930689>

しかしClojureの道に挑戦してしまった...地雷だらけ.

基本方針としては, Google Cluud FunctionsのJava11ランタイムのページをみながら,
functions-framework-java を利用する.

-   <https://cloud.google.com/functions/docs/concepts/java-runtime>
-   <https://github.com/GoogleCloudPlatform/functions-framework-java>

2022.01時点での注意点としては,

-   他のJVM言語のところにClojureが登場しない.
    -   <https://cloud.google.com/functions/docs/concepts/jvm-langs>
    -   Scala, Kotlin, Groovyは登場する.
    -   他のJVM言語を真似してClojureを実行しようとすると,エラー.
-   デプロイ方式は２つあるがおそらくローカルビルドでないと失敗.
    -   <https://cloud.google.com/functions/docs/concepts/java-deploy>
    -   ソースからのデプロイはpom.xmlとソースのuploadは成功するがclojureのビルドでコケる. そもそもCloud Functionsで使われているCloud BulildでClojureのビルドに対応しているのか怪しい. ClojureCoreその他ははdefaultでJava8でビルドされている.
        一方Cloud Functionsのランタイムは11.
    -   したがってuberjar(fatjar)をローカルで作成して.classファイルと一緒にuploadするのがいい.
-   以下の3つのリポジトリが参考になる.
    -   <https://github.com/pepijn/google-cloud-functions-clojure>
    -   <https://pathom3.wsscode.com/docs/tutorials/serverless-pathom-gcf/#gcf-deploy>
    -   <https://github.com/atomist-skills/gcf-java11-clojure>
-   ハマりポイントはエントリポイントをJavaで用意するところ.
    -   Clojureで用意しようとしてもビルドエラーする.
-   ruberjarのビルドにはの [📝tools.build]({{< relref "20220119063524.md#clojure-cli-tools-dot-deps-clojure-build-tool" >}}) のguideをみて,
    JavaソースをコンパイルしてClojureコードをuberjarで.jarファイルに含める.


## 📝Google Cloud Run w/ Clojure {#google-cloud-run-w-clojure}

[🏷Jib]({{< relref "20220316081935.md#jib-build-container-images-for-your-java-applications" >}}) を利用してコンテナビルドする.

-   [Clojure in Google Cloud Run with Jib – Hannu Hartikainen](https://hannuhartikainen.fi/blog/clojure-cloud-run/)
-   [Clojure app on Google Cloud Run | 3sky's notes](https://blog.3sky.dev/article/google-run-clojure/)
-   [Google Cloud Run で Clojure アプリケーションを実行しよう | Micheam's TechBlog](https://blog.micheam.com/2019/12/12/how-to-run-clojure-on-google-cloud-run/)

実際に検証した感触ではCloud Functionsよりも圧倒的に楽.

ref: <https://github.com/tsu-nera/meigen-bot-gcloud-run-clj>

最近, [jibbit](https://github.com/atomisthq/jibbit) というclojureからjibを扱いやすしたツールも登場(2022/01).

-   <https://twitter.com/kipzter/status/1480982692036591620>
-   [Containerizing a Clojure Project | Atomist Blog](https://blog.atomist.com/containerizing-a-clojure-project/)


## References {#references}

-   🔗[オブジェクト指向とはまったく違うClojureの世界と実際のWeb開発 - 紙箱](https://boxofpapers.hatenablog.com/entry/2018/06/24/160802)
-   🔗[Clojure で Web 開発をはじめてみよう — Clojure の日本語ガイド](http://ayato-p.github.io/clojure-beginner/intro_web_development/index.html)
-   <http://ayato-p.github.io/clojure-beginner/intro_web_development/index.html>
    -   ayato-pさんの作.
        -   たしかわたしがClojureにはじめて触れた2015ごろにはすでにあった気がする.
-   [Web Development with Clojure (第3版) の紹介 - Qiita](https://qiita.com/t-cool/items/59c52d6e80beca2fdee8)
