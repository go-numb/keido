+++
title = "📝Clojure Product Development"
tags = ["WIKI"]
draft = false
+++

up: [📂Clojure Development]({{< relref "20220211141917.md" >}}) tags: [🏷Clojure]({{< relref "20211111225741.md" >}})

Clojureプロダクト開発で役立つライブラリとフレームワークまとめ.

必要に応じてトピックごとにリファクタリングすること.

-   refs:
    -   [📝Clojure Web Development]({{< relref "20220118092453.md" >}}) =&gt; Web関係はこっち
    -   [📝Clojure API Client Development]({{< relref "20220209102028.md" >}}) =&gt; Client API関係はこっち
    -   [📝Clojure Style Rules &amp; Conventions]({{< relref "20220313110515.md" >}}) =&gt; コーディング規約や慣習はこっち
    -   [📝Clojure Architecture]({{< relref "20220314120812.md" >}}) =&gt; 設計周り


## Clojure: Backend Framework {#clojure-backend-framework}


### Clojure: Duct {#clojure-duct}

<https://github.com/duct-framework/duct>

[Integrant](#clojure-integrant) をベースにした拡張機能を提供.
Webフレームワークではなくもっと汎用的なもの.

-   [Ductモジュール入門](https://www.slideshare.net/KentOhashi/duct-module-getting-started)
-   [はじめてのDuct - Uzabase for Engineers](https://tech.uzabase.com/entry/2018/04/03/115236)


#### 💡 Javaからのアナロジー {#javaからのアナロジー}

小さな構成のシステムをJavaで作成するならモジュールごとにクラス分割するが,
Ductはクラスに初期化データとその方法を定義するためのコンストラクタを定義するようなものか?
責務を意識したクラス設計とはドメイン分割.


### Clojure: Roll {#clojure-roll}

<https://github.com/dimovich/roll>

backend for Clojure.

Ductよりもさらにシンプル, integrantがベース.


## Clojure: 状態管理とシステム {#clojure-状態管理とシステム}

いろいろあるがナウいのはIntegrantかな？

-   [stuartsierra/component](https://github.com/stuartsierra/component)
-   [tolitius/mount](https://github.com/tolitius/mount)
-   [weavejester/integrant](https://github.com/weavejester/integrant/projects?type=beta)

状態管理ライブラリとは関数型パラダイム固有のものかな？ Redux的な.


### そもそもシステムとコンポーネントとは {#そもそもシステムとコンポーネントとは}

システムはそもそもアプリケーションが長い間起動しているときに必要となる考え.

スクリプトやユーティリティの実行では必要ないのだ.
それらは処理の終了がプログラムの終了でありリソースの開放である.

バックグラウンド実行をし続ける部分で構成されるアプリケーション,
その部分が依存関係にあり初期化時に関係を構築するもの, これがシステム.

システム構築する部品=コンポーネントは単純化すれば,
On/Offの操作によるStatefulなObjectである.

ref: [Systems in Clojure](https://grishaev.me/en/clj-book-systems/)


### Clojure: Integrant {#clojure-integrant}

データ駆動設計によるアプリケーションを作成するためのマイクロフレームワーク.

<https://github.com/weavejester/integrant>

[Dependency Ingection]({{< relref "20220310114456.md" >}}) をClojureで実現.

設定データに対する初期化関数を定義でき, 設定データの定義から実体を生成.


#### Usage {#usage}

-   integrant
    -   **configuration map** をもとに生成されるmicro-serviceの1つの単位.
-   configuration map
    -   keyの定義をまずする. これは具体的な実装へと初期化される入力情報.
    -   Clojureのmapとして表現するかEDNファイルとして外部ファイルに定義する.
    -   configuration map同士は **ig/ref** で 参照することができる.
-   ig/init-key で integrant serviceの初期化におけるデータと関数を定義.
-   ig/halt-key!でintegrant serviceのinit-keyの定義を破棄する関数を定義.
-   ig/initにconfiguration mapを渡すことで, 依存関係に従って integrant を初期化.
-   init/halt!で 破棄.

<!--listend-->

```clojure
(defmethod ig/init-key :handler/greet [_ {:keys [name]}]
  (fn [_] (resp/response (str "Hello " name))))
```

-   {:keys [name]}はClojure 分配束縛の記法.
    -   ref: [📝Destructuring]({{< relref "20220116094551.md#clojure-分配束縛--destructuring" >}})
-   keyに ::hogeみたいな 2つのコロンをみかける. ::hogeは :(namespace)/hogeの意味.
    -   REPLで評価するとわかる, reader syntax.


#### Usage: Integrant suspend/resume {#usage-integrant-suspend-resume}

<https://github.com/weavejester/integrant#suspending-and-resuming>

Integrantはinitとhalt, つまりシステムの開始と終了の機能を提供する.

suspend/resumeは主に **開発用** である.
そして使いこなすにはatomとdelayをつかうというひと工夫を加える.


#### 💡考察: Integrantで状態を管理するということ(as State Management) {#考察-integrantで状態を管理するということ--as-state-management}

Clojureの世界では, 普通は状態をatomで管理する.
Integrantを導入することで, 各namespaceに散らばるatomで宣言された状態を
systemというひとつの状態に紐づけてまとめることができる.
そしてこのツリー構造で状態を管理するからこそシステムの停止や再起動が用意にできる.

逆に言うと, Integrantを利用するということは,
namespaceでatomを宣言しないということなのかな？

---

[Integrant: how to store and access the running system? : Clojure](https://www.reddit.com/r/Clojure/comments/ar87te/integrant_how_to_store_and_access_the_running/)

&gt; Systems in Integrant are intended to be autonomous.

&gt; Anyway, my point is that it seems to me Integrant still requires a whole app buy-in in the sense that, unlike with Mount, you have to thread all your state through a single entry-point.

systemはthreadで動作する再帰プロセス.
しかしこれはIntegrantと言うよりも関数型プログラミングのイディオム.

&gt; Only constants should be global.

定数のみが参照可能であり状態は隠されているという考え(debug除く).


#### 💡考察: Java Command Patternからのアナロジー {#考察-java-command-patternからのアナロジー}

クラスというものを単なる抽象データ構造と捉えると,
クラスには属性としての値と関数値の集合であり,
オブジェクトとはそれをメモリ上に領域確保した状態.

ig/init-keyでやっていることは値とその初期化関数のpairのbindingであり,
ig/init-keyで定義したpairの集合をig/initでまとめて初期化している.

そうすると, ig/init-keyで初期化したそれぞれのオブジェクトを１つのオブジェクトに
bindingして管理しているようにもみえる.
管理ということで, suspend, resume,
haltはオブジェクトを [Command Pattern]({{< relref "20220309184220.md#振る舞いに関するデザインパターン" >}}) で扱うようなものとして捉えれば納得がいく.

(アナロジーとして類推しただけで実装を読んではない...後で読む).


#### References {#references}

-   [Enter Integrant: A Micro-framework for Data-Driven Architecture (James
    Reeves, 2017) - YouTube](https://www.youtube.com/watch?v=tiWTpp_DPIQ&t=2276s)
    -   作者によるプレゼンテーション動画.
-   [Integrant入門(1) - Integrantの基本 - ayato-p](https://scrapbox.io/ayato-p/Integrant%E5%85%A5%E9%96%80(1)_-_Integrant%E3%81%AE%E5%9F%BA%E6%9C%AC)
-   [はじめてのDuct - Uzabase Tech](https://tech.uzabase.com/entry/2018/04/03/115236)
    -   integrantについても書かれてる.


### 💡考察: Integrant Rationale cf. Component {#考察-integrant-rationale-cf-dot-component}

Clojure Component の代替を意識して,
とくにComponentが依存関係をプログラム内(Clojure Source Code)で管理するが,
IntegrantはEDNで管理するところがこだわりポイント.

すなわちIntegrantはClojure MapでもEDNでもどちらでも構成定義できるが,
設計動機からいえばEDNつかえよ！ということかな？


### 💡考察: Component/MountとIntegrantの決定的違いはOOP vs FP {#考察-component-mountとintegrantの決定的違いはoop-vs-fp}

ComponentやMountを使ったことがないので以下はリンク先からの理解.

[Integrant: an alternative to Component and Mount : Clojure](https://www.reddit.com/r/Clojure/comments/5gvhi2/integrant_an_alternative_to_component_and_mount/)

ComponentやMountは状態をグローバルに参照することができるので,
関数の引数としてもらう必要がない.

Integrantは状態がライブラリの中に隠されていて自由に参照できない.
そのためその状態に対する操作は関数の引数としてもらって変化した値を返すように書く.
またはhandlerの定義として状態とそれに対する操作を1つにbindingする.

Webフレームワークならたくさんのサンプルを見ながら自然とこの初期化で状態と関数を
handlerとしてbindingするパターンに従えばいいものの,
webとは関係なく単にintegrantを使おうとしたとき,
ベストプラクティスがないので自分の流儀で実装しがち, 本質を考えよう.

初期化時に自前でnamespaceにatomに保存しておく方法はそもそもフレームワークで状態を管理する考えに反するアンチパターン.

Integrantは関数型プログラミング(FP)の考えに近い.
一方Componentの考えはクラスやOOPに近い.

とくにFPでシステムを構築すると冪等性を獲得することができ,
これが開発時にとくに役に立つ(cf. [Reloaded Workflow]({{< relref "20220117205249.md#reloaded-workflow" >}})).
Componentは自分が初期化済みかどうかはComponent自身しかわからない.

-   [ComponentとIntegrantの違い - ayato-p](https://scrapbox.io/ayato-p/Component%E3%81%A8Integrant%E3%81%AE%E9%81%95%E3%81%84)
    -   <https://twitter.com/athos0220/status/931003506638458882>


## Clojure: ロギング(Logging) {#clojure-ロギング--logging}

Javaの資産を使うか否かが採用のポイントかな？
Javaのロギングライブラリは歴史がある.
ログはViewerがよいとワクワクするからな.


### tools.logging {#tools-dot-logging}

<https://github.com/clojure/tools.logging>

clojure tools.logging libaryでJavaの資産を活用.

ref: [🖊Logbackのログを見やすくする方法(ファイルをgrep, Lilith) | Futurismo](https://futurismo.biz/archives/6825/)


### timbre {#timbre}

Pure Clojure/Script logging library.

<https://github.com/ptaoussanis/timbre>

[slf4j-timbre](https://github.com/fzakaria/slf4j-timbre) をつかうとJavaのロギングライブラリと連携可能.

なんかドキュメントがわかりにくいな...

日本の時刻設定例:

```clojure
(def timbre-config {:timestamp-opts {:pattern  "yyyy-MM-dd HH:mm:ss,SSS"
                                     :locale   (java.util.Locale. "ja_JP")
                                     :tiemzone (java.util.TimeZone/getTimeZone "Asia/Tokyo")}})
(timbre/merge-config! timbre-config)
```


## References {#references}

-   [The Clojure Toolbox](https://www.clojure-toolbox.com/)
    -   逆引きのClojure Libraryまとめページ.
