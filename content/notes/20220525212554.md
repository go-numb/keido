+++
title = "💻essay: Rees by Jonathan Rees"
tags = ["ONLINE", "SOURCE"]
draft = false
+++

-   title: essay: Rees by Jonathan Rees
-   authors: Jonathan Rees
-   url:  [Rees Re: OO](http://practical-scheme.net/trans/reesoo-j.html#)
-   refs:
    -   [📝オブジェクト指向プログラミング]({{< relref "20220117174424.md" >}})

--

オブジェクト指向というのは, このリストのいろいろなサブセットとして 定義されているようだ. つまり, 「オブジェクト指向」というのはちゃんと定義された概念ではない!


## Literature Notes {#literature-notes}


### カプセル化 {#カプセル化}

型の実装を構文的に隠蔽できること. 例えば C や Pascal では何かが構造体であるか配列であるか常に意識することになるが, CLU や Java ではその違いを隠すことができる.


### 保護 {#保護}

型の使用者がその実装をのぞくことができないこと. これによって,ふるまいさえ変えなければ, 実装を変更しても型の使用者に影響を与えないことが保障でき, またパスワードのような情報が漏れ出さないようにることもできる.


### アドホックポリモルフィズム {#アドホックポリモルフィズム}

関数やパラメータつきデータ構造が たくさんの異なる型の値をとることができる.


### パラメトリックポリモルフィズム {#パラメトリックポリモルフィズム}

関数やデータ構造が任意の値 (例:任意のオブジェクトのリスト)に対してパラメタライズできること.

ML と Lisp はこれを持つ. Java は非 Object な型のために, これを完全に持つとは言えない.


### 全てはオブジェクトなり {#全てはオブジェクトなり}

全ての値はオブジェクト. Smalltalk では真だが, Java では (int 等のため) 真ではない.


### メッセージを送ることだけができる (All you can do is send a message, {#メッセージを送ることだけができる-all-you-can-do-is-send-a-message}

AYCDISAM) = Actor モデル

オブジェクトを直接いじることはできず, それと通信する, もしくはそれを起動することのみができる. Java における field の存在はこれに反する.


### 仕様継承 = サブタイピング {#仕様継承-サブタイピング}

ふたつの異なる型で, 一方の型の値が もう一方の型の値として使われても型の正当性を破らないことを言語が保障できるようなもの.

(例: Java のインタフェース継承).


### 実装継承, 再利用 ひとまとまりのコードを書いたら, それと似たコード {#実装継承-再利用-ひとまとまりのコードを書いたら-それと似たコード}

(そのスーパーセット) が制御された方法で生成できる.

つまりコードをコピーして編集する必要がない. 制限された, 特殊な抽象化である. (例:Java のクラス継承).


### 「関数の積和 (sum-of-product-of-function) 」パターン {#関数の積和--sum-of-product-of-function--パターン}

オブジェクトは (実質的に) 有限の簡単な名前の集合から選ばれるキー引数を第一引数に取り, それによってメソッドを呼び出す関数として動作する.
