+++
title = "📝Clojure Java Interop"
tags = ["WIKI"]
draft = false
+++

up: [📂Clojure Core]({{< relref "20220112142936.md" >}}) refs: [🏷Java]({{< relref "20220303203801.md" >}})

ClojureとJavaのやりとりをまとめ.


## ClojureからJavaを呼び出し {#clojureからjavaを呼び出し}

-   メソッドを呼ぶには, メソッド名の前に **.** を書く.
-   クラスを生成するには, クラス名のあとに **.** を書く.


## Clojure-Java HashMap Interop {#clojure-java-hashmap-interop}


### howto: Clojure - JavaのHashmapの変換 {#howto-clojure-javaのhashmapの変換}

```clojure
(def java-map (java.util.HashMap. test-data))
(def clj-map  (into {} java-map))
```


### howto: Clojureのkeywordを stringにするには？ {#howto-clojureのkeywordを-stringにするには}

clojure.walkライブラリ使える. <https://clojuredocs.org/clojure.walk>

-   strinify-keys: keywords to string
-   keywordize-keys: string to keywords


## Clojure-Java Class {#clojure-java-class}


### howto: Javaのclassを生成するには? {#howto-javaのclassを生成するには}

ref: <https://clojure.org/reference/compilation>

namespaceに (:gen-class)を記述する.
namespaceを持つ .classファイルが生成される.

default(AOT compile?) では compileするとバラバラのファイルが生成され, .classがない.

```text
drwxr-xr-x 3 tsu-nera tsu-nera 4.0K  2月 16 13:40  ClojureHelloWorld
-rw-r--r-- 1 tsu-nera tsu-nera 1.4K  2月 16 13:40 'ClojureHelloWorld$fn__273.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.1K  2月 16 13:40 'ClojureHelloWorld$fn__275$fn__276.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.3K  2月 16 13:40 'ClojureHelloWorld$fn__275.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.9K  2月 16 13:40 'ClojureHelloWorld$loading__6737__auto____271.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.1K  2月 16 13:40  ClojureHelloWorld.clj
-rw-r--r-- 1 tsu-nera tsu-nera 2.4K  2月 16 13:40  ClojureHelloWorld__init.class
```


### howto: JavaのスーパークラスをClojureで継承するには？ {#howto-javaのスーパークラスをclojureで継承するには}

**proxy** マクロをつかう.
これはJavaのクラスを引数にして無名のサブクラスを返すので適当な値にbindする.

ref: <https://clojure.org/reference/java_interop#_implementing_interfaces_and_extending_classes>


## Clojure: 型ヒント(Type Hinting) {#clojure-型ヒント--type-hinting}

[Clojure - Java Interop](https://clojure.org/reference/java_interop#typehints)

Clojureは動的型付け言語だが動的型付け言語のJavaの上に構築されているため,
暗黙的な型はリフレクションによって型推論されている.

そのため型hintを設定することで型推論の効率化をすることができ,
コンパイルや実行速度の最適化をすることができるかもしれない.

Clojureでは, **^** という記号を Record/Type/Protocol/Java Classに設定して変数を宣言することで型ヒントを実現する.

---

ref: [[Clojure] 型を指定すると速い | Basic Werk](http://basicwerk.com/blog/archives/1479)

Clojureは型ヒントを使ってコンパイラを助けることで,
パフォーマンスの重要なコード領域に対してリフレクションを避けることができる.

ClojureはローカルコンテキストにおけるJavaの基本型を使った高速な計算や算術演算をサポートする.
すべてのJava基本型（int, float, long, double, boolean, char, short, byte）がサポートされている。


## Active Recalls {#active-recalls}


### ClojureからJavaのメソッドの呼び出すには？ {#clojureからjavaのメソッドの呼び出すには}

メソッド名の前に.をおいて呼び出す. (.methodName )


### ClojureからJavaのクラスを生成には？ {#clojureからjavaのクラスを生成には}

クラス名のあとに.をおいて呼び出す. (Classname. )
