+++
title = "📝Clojure Java Interop"
tags = ["WIKI"]
draft = false
+++

up: [📂Clojure Core]({{< relref "20220112142936.md" >}}) refs: [🏷Java]({{< relref "20220303203801.md" >}})

ClojureとJavaのやりとりをまとめ.


## ClojureからJavaを呼び出し {#8f6763}

-   メソッドを呼ぶには, メソッド名の前に **.** を書く.
-   クラスを生成するには, クラス名のあとに **.** を書く.


## ClojureからJavaのライブラリを利用する {#e01225}

最も大事かもしれないトピック.

[twitter-text/java](https://github.com/twitter/twitter-text/tree/master/java) をClojureから利用したいとする. このライブラリはClojureから使っている人がほぼいない.


### Java LibraryのClojureプロジェクトへのインストール(deps.edn) {#8706f6}

まず大抵のJava libraryはmvn経由でインストールでき, たとえばGitHubのREADME.mdにはこんな感じのxmlがある.

```xml
  <dependencies>
    <dependency>
      <groupId>com.twitter.twittertext</groupId>
      <artifactId>twitter-text</artifactId>
      <version>3.1.0</version> <!-- or whatever the latest version is -->
    </dependency>
  </dependencies>
```

deps.ednには以下のように **<groupId>/<artifactId> {:mvn/version <version>}** と記述すればいい.

```clojure
com.twitter.twittertext/twitter-text {:mvn/version "3.1.0"}
```

これでClojureのライブラリインストールと同じようにインストールできる.


### Java LibraryをClojureソースから読み込み(import) {#fa627f}

[twitter-text/TwitterTextParser.java](https://github.com/twitter/twitter-text/blob/master/java/src/main/java/com/twitter/twittertext/TwitterTextParser.java) を使うとする.

には com.twitter.twittertextのパッケージを **import** する. packageはソースを覗くと **package** という宣言のあとにpathがある.

以下のようにimportしてつかう.

```clojure
(ns dev
  (:import
   (com.twitter.twittertext
    TwitterTextParser)))
```


## Clojure-Java HashMap Interop {#88e7e9}


### howto: Clojure - JavaのHashmapの変換 {#749eb7}

```clojure
(def java-map (java.util.HashMap. test-data))
(def clj-map  (into {} java-map))
```


### howto: Clojureのkeywordを stringにするには？ {#4934c1}

clojure.walkライブラリ使える. <https://clojuredocs.org/clojure.walk>

-   stringify-keys: keywords to string
-   keywordize-keys: string to keywords


## Clojure-Java Class {#bbbfb7}


### howto: Javaのclassを生成するには? {#fe144d}

ref: <https://clojure.org/reference/compilation>

namespaceに (:gen-class)を記述する.
namespaceを持つ .classファイルが生成される.

default(AOT compile?) では compileするとバラバラのファイルが生成され, .classがない.

```text
drwxr-xr-x 3 tsu-nera tsu-nera 4.0K  2月 16 13:40  ClojureHelloWorld
-rw-r--r-- 1 tsu-nera tsu-nera 1.4K  2月 16 13:40 'ClojureHelloWorld$fn__273.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.1K  2月 16 13:40 'ClojureHelloWorld$fn__275$fn__276.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.3K  2月 16 13:40 'ClojureHelloWorld$fn__275.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.9K  2月 16 13:40 'ClojureHelloWorld$loading__6737__auto____271.class'
-rw-r--r-- 1 tsu-nera tsu-nera 1.1K  2月 16 13:40  ClojureHelloWorld.clj
-rw-r--r-- 1 tsu-nera tsu-nera 2.4K  2月 16 13:40  ClojureHelloWorld__init.class
```


### howto: JavaのスーパークラスをClojureで継承するには？ {#ab76df}

**proxy** マクロをつかう.
これはJavaのクラスを引数にして無名のサブクラスを返すので適当な値にbindする.

ref: <https://clojure.org/reference/java_interop#_implementing_interfaces_and_extending_classes>


## Clojure: 型ヒント(Type Hinting) {#26eed20d-611d-46c4-bd37-d60c2f20a1d7}

[Clojure - Java Interop](https://clojure.org/reference/java_interop#typehints)

Clojureは動的型付け言語だが動的型付け言語のJavaの上に構築されているため, 暗黙的な型はリフレクションによって型推論されている.

そのため型hintを設定することで型推論の効率化をすることができ, コンパイルや実行速度の最適化をすることができるかもしれない.

Clojureでは, **^** という記号を Record/Type/Protocol/Java Classに設定して 変数を宣言することで型ヒントを実現する.

---

ref: [[Clojure] 型を指定すると速い | Basic Werk](http://basicwerk.com/blog/archives/1479)

Clojureは型ヒントを使ってコンパイラを助けることで, パフォーマンスの重要なコード領域に対してリフレクションを避けることができる.

ClojureはローカルコンテキストにおけるJavaの基本型を使った高速な計算や算術演算をサポートする. すべてのJava基本型（int, float, long, double, boolean, char, short, byte）がサポートされている。


## Active Recalls {#b27a23}


### ClojureからJavaのメソッドの呼び出すには？ {#3e6acd}

メソッド名の前に.をおいて呼び出す. (.methodName )


### ClojureからJavaのクラスを生成には？ {#96b598}

クラス名のあとに.をおいて呼び出す. (Classname. )


## References {#d95867}

-   [Clojure-Java Exception Interop]({{< relref "20220331055419.md#afb4936b-9d05-4e5f-bfc7-5071962c34d4" >}})
