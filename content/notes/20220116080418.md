+++
title = "📝Clojure:名前空間と変数束縛(Bindings and Namespaces)"
tags = ["WIKI"]
draft = false
+++

Clojureでは，変数の名前空間と束縛の関係は以下のようになる.

ref: [📂Clojure Core]({{< relref "20220112142936.md" >}})


## Clojure: 名前空間(Namespaces) {#clojure-名前空間--namespaces}

Clojure の名前空間を namespaceという. ns で宣言する. \\\*ns\\\* で参照する.

ある名前空間から別の名前空間を参照するには requireをつかう.

-   require のみ 省略なしの表記でアクセスできる(namespace/symbols)
-   require :as 省略した表記でアクセスできる(省略namesapce/symbols)
-   require :refer :all 名前空間を書かない表記でシンボルにアクセスできる(symbols)

[🏷environments]({{< relref "20220305075933.md#valuables-変数" >}})


### Clojure: 名前空間のスタイルガイド {#clojure-名前空間のスタイルガイド}

[Clojureスタイルガイド](https://totakke.github.io/clojure-style-guide/) より名前空間に関わる部分を抜き出した.

-   名前空間は1ファイルに１つ.
-   名前空間の命名規約はkebab-case(lisp-case).
-   深い名前空間のセグメントは悪い(せいぜい5つまで).

また. library-name.coreみたいなのはLeiningen Projectの慣習.

名前空間のフォーマットについて.

-   refer, require, importの順に並べる.
-   適切な改行.
-   requireとimportを整理して並べる.
-   Idiomatic な名前空間の名前をつかう.
    -   具体例は以下にいろいろ書いてある. (io, set, pp, etc..).
    -   [Use Idiomatic Namespace Aliases -  bbatsov/clojure-style-guide](https://github.com/bbatsov/clojure-style-guide/blob/master/README.adoc#use-idiomatic-namespace-aliases)
    -   要は長い名前を使うのではなくて省略しましょうということ.

これらは人間が意識するべきではないのでツールに任せたいところだ.
Emacs CIDERなら cljr-clean-ns or clojure-sort-ns.


### Clojure: Scope {#clojure-scope}

Clojureはデフォルトで静的スコープを採用している.

[🏷Scope]({{< relref "20220305075933.md#scope-スコープ" >}})


#### Dynamic Scope {#dynamic-scope}

動的スコープ. Emacsなら常識か.

ClojureのDynamic Scopeは **bindings** マクロで定義する.
名前空間を超えて, 同一スレッド内なら値(var)が参照可能.

Lispの慣例として, アスタリスク(\*)でsymbolを囲む.

そういう意味だと, スレッドローカルといえるかも.
スレッドをまたぐ方法はまた別にある?
(未調査, keyword: "binding conveyance").

refs: [Clojure - Vars and the Global Environment](https://clojure.org/reference/vars)


### howto: namespaceにbindingsされたシンボルを確認するには？ {#howto-namespaceにbindingsされたシンボルを確認するには}

ns-xxx という関数で調べる.

-   ns-map
-   ns-publics
-   ns-interns
-   ns-refers
-   ns-imports

たとえば, (ns-map 'my-space)でmy-spaceにbindingsされているvarをすべて返す.

ns-mapは全て.
ns-publicsはpublicなvars.
ns-internsはrequireやreferなどを除くそのnamespaceで定義されたもの.

しばしば, (keys (ns-interns 'my-space'))など, keys methodと連携させる.

M-x cider-browse-nsでEmacs Bufferで閲覧できる.


## Clojure: 変数束縛(Bindings) {#clojure-変数束縛--bindings}

-   変数の名前空間への束縛をdef
    -   list formでbindingする.
    -   ex.) (def developer "Alice")
    -   無名関数はfn
-   変数の一時的な束縛を let
    -   vector formでbindingする.
    -   ex.) (let [developer "Alice in wonderland"])
-   関数の定義はdefn
    -   これはdefのシンタックスシュガーでもある.
-   無名関数はfn
    -   \#() でも表現可能.

[🏷bindings]({{< relref "20220305075933.md#valuables-変数" >}})


### Clojure: clojure.lang.Var {#clojure-clojure-dot-lang-dot-var}

**def** マクロは, clojure.lang.Varオブジェクトを生成する.

```clojure
user> (def x)
;; => #'user/x
user> x
;; => #object[clojure.lang.Var$Unbound 0x7d08131d "Unbound: #'user/x"]
```

varのリーダマクロは, **#'**

varにはMetaDataを設定できる. よく見かける代表的なのは,

-   :dynamic
    -   同一スレッド内で再定義可能.
    -   (def ^:dynamic foo 1)
-   :private
    -   namespaceを超えて参照不可.
    -   (def ^:private bar 2)

ref. [Clojure: MetaData]({{< relref "20220116162321.md#clojure-metadata" >}})


### Clojure: defonce {#clojure-defonce}

defもdefonceも名前空間に変数束縛をするが,
すでに変数が存在する場合, defは上書きをする. defonceはスキップする.

ref: [What is the difference between def and defonce in Clojure? - Stack Overflow](https://stackoverflow.com/questions/37346984/what-is-the-difference-between-def-and-defonce-in-clojure)


#### defonceとatomとhotreload {#defonceとatomとhotreload}

defonceはhotreloadの文脈でatomと合わせて登場することが多い.

再起動のときにメモリをたくさん使ったり外部通信して時間がかかったりするときに,
いちいちインスタンスを再作成してるとボトルネックになるのでdefonceをつかう.

ただしreplの再起動でよく利用される tools.namespace.replのrefresh関数は,
たとえdefonceで定義されていたとしても初期化するので注意.

ref: <https://github.com/clojure/tools.namespace#reloading-code-preparing-your-application>

たとえばM-x cider-eval-bufferをうっかりEmacsで実行してバッファまるごと読み込み直しても,
defonceで宣言しているならばその変数束縛はスキップされる.

まあこのあたりのhotreloadによるDX改善は自分で考えるよりもベストプラクティスを真似るのがいいのかも.

ref: [Reloaded Workflow]({{< relref "20220117205249.md#reloaded-workflow" >}})


## ✅ Active Recalls {#active-recalls}


### Clojure の 無名関数のシンタックスはなんですか？ {#clojure-の-無名関数のシンタックスはなんですか}

fn or #()


### Clojureの名前空間の宣言方法と参照方法はなんですか? {#clojureの名前空間の宣言方法と参照方法はなんですか}

ns と \\\*ns\*


### Clojureで名前空間を参照するためのシンタックスはなんですか? {#clojureで名前空間を参照するためのシンタックスはなんですか}

require


### Clojure nsの属性で :requireと:importの違いはなんですか？ {#clojure-nsの属性で-requireと-importの違いはなんですか}

どちらもnamespaceに他のnamespaceで定義された宣言を取り込むが,
requireはclojureのライブラリ, importはJavaのクラスで利用する.


### Clojureでdefとdefonceの違いはなんですか？ {#clojureでdefとdefonceの違いはなんですか}

名前空間に変数束縛するとき,すでに変数が存在する場合の挙動が違う.

defは上書きをする. defonceはスキップする.
