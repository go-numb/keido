+++
title = "📝Clojure Exception: 例外"
tags = ["WIKI"]
draft = false
+++

Clojureにおける例外処理やエラーハンドリングについてまとめ.

-   up: [📂Clojure Core Languages]({{< relref "20220112142936.md" >}})
-   refs.
    -   [🔖Exceptions]({{< relref "20220305075933.md#5c863837-2d4a-457c-9566-ed1748d49e38" >}})
    -   [📝Java Exception: 例外]({{< relref "20220731122944.md" >}})


## Clojure-Java Exception Interop {#afb4936b-9d05-4e5f-bfc7-5071962c34d4}

Javaの仕組みを使う. したがってJavaの知識があるとbetter.

-   Javaのようにtry/catch/finallyが利用できる.
-   throwシンタックスで例外を引数にとり例外を発生させる.
    -   例外はJavaのクラスで作成できる(Exception. )
    -   Clojureの記法でex-infoはmessageとmapを受取リ例外を発生させる.
    -   Clojureの記法でex-dataはex-infoで入力したmapを展開する.

<!--listend-->

```clojure
(try
  (throw (ex-info "bad" {:a 1 :b 2}))
  (catch clojure.lang.ExceptionInfo e
    (prn "caught" e)))
```

ex-messageが行メッセージ, ex-dataが詳細情報.

```clojure
(try
  (let [response (http/post
                   "http://localhost:8080/v1/leads"
                   {:form-params {:foo "somethingBad"}})]
    (log/info "This is the response" response))
  (catch Exception e
    (log/error (str "Oops! " (ex-message e)))
    (log/error (str "Because! " (ex-data e))))
```


## 連続的なプロシージャ呼び出しのエラーハンドリングどうするか問題 {#39688d}

Clojureでシステムの外部とやりとりをするときに，ライブラリを使って一連の動作をするシーンがよくある. このとき, 例外処理をどうするか問題. とくにRESP API呼び出しやDBとの通信などで頻発する.

```clojure
(try
   (let [value (func-that-throws)]
      (act-on-value value))
   (catch Exception e
      (log/error e "func-that-throws failed")))
```

threading-macroをカスタムするようにRailway oriented programming?で記述するほうほうと, try-catchとifを用いてゴリゴリ処理する方法があるようだ.

ref. [Clojure とエラーハンドリング at 2021 - Qiita](https://qiita.com/MeguruMokke/items/530159edf0c41a9df6b1)

手続き的な処理をletにずらずら書いていくのはどうも違和感がある(個人的な感想). そうするとスレッディングマクロでbodyに書いていくスタイルはよりClojureらしくてコードの見た目はよい. しかし仕組みがdefaultでClojureに組み込まれていないので汎用的ではない. 手続きが数個に過ぎないならばtryとletとif, そうでなければrailwayを使えばいいかな.


### Railway oriented programming(鉄道指向プログラミング) {#349a21}

鉄道指向プログラミングとは、F# で有名だったプログラミングスタイル. 関数の返り値に正常系の結果 result とそれ以外のパターン err のタプル [result, err] を想定し、実行フローの各プロセスで得られる err が nil でない時 Early-Return をかける方式. (ScalaやHaskellでも合った気がする).

-   refs.
    -   [Railway oriented programming, clojure and exception handling: why and how?](https://medium.com/appsflyer/railway-oriented-programming-clojure-and-exception-handling-why-and-how-89d75cc94c58)

---

さらに, Javaの関数を呼び出すときにライブラリが例外を挙げずにNullを返すときは **some->** というスレッディングマクロを使う方法もClojureのガイドにあった.

ref. [some-> - Threading Macros Guide](https://clojure.org/guides/threading_macros#_some_some_and_cond)


### try-catch and if-let {#826a20}

tryとletをつかって愚直に書く. コードは汚くなるものの実装も理解もこっちは容易.

ref. [🔎if-let は処理の結果による分岐でつかう]({{< relref "20220116083656.md#cf8a7205-5993-4091-af92-a611dd48fd38" >}})

---

try-letというマクロを提供するライブラリもある.

-   refs.
    -   [clojure - How to handle exceptions that occur in let bindings or body - Stack Overflow](https://stackoverflow.com/questions/20335760/how-to-handle-exceptions-that-occur-in-let-bindings-or-body)
    -   [GitHub - rufoa/try-let: Better exception handling for Clojure let expressions](https://github.com/rufoa/try-let)


### 🤔そもそもConsistentを考慮してプログラミングするべきなのか {#d1adfc}

Clojureは並列プログラミングを強く意識してトランザクションという概念もあるくらいなので一連のオペレーションの途中でエラーが失敗したらその一連の処理自体そのものを失敗させるように作るべきなのかもしれない. つまりConsistent, 一貫性という概念.


## slingshot: Enhanced throw and catch for Clojure {#2e6ef68b-b405-489c-8194-17a5e54f3b6d}

ref. [GitHub - scgilardi/slingshot](https://github.com/scgilardi/slingshot)

Clojureは基本的にJavaの例外の仕組みを利用するが, さらにClojureに合わせてカスタマイズしたライブラリ.

たとえば [clj-http]({{< relref "20220209102028.md#13a79f1f-0d95-4f2a-8c4c-b77c4ed69be1" >}}) では HTTP Responseが正常終了以外の場合はこのインスタンスを返すため, slingshotに合わせたエラーハンドリングが期待される.

**try+** と **thorw+** という２つのマクロを提供.


### Referenecs {#e2d205}

-   [Part6: TODO アプリを組み上げる — エラーをうまく処理する](https://ayato-p.github.io/clojure-beginner/intro_web_development/part6_build_up_our_app.html#id12)
    -   slingshotをつかったハンドリング例(ja).


## Clojure例外のトピック {#8afb1f}


### <span class="org-todo todo _">⚙</span> pcoll pattern on Clojure {#896dfae0-53c2-4dad-b89c-334bf587fd29}

関数呼び出しをtry-catchで包む方法.

```clojure
(defn pcall [f & args]
  (try
    [true (apply f args)]
    (catch Exception e [false e])))
```

ref. [pcoll pattern in clojure http request]({{< relref "20220209102028.md#3f097ce3-22de-4fa6-b151-0e9a6f2d905d" >}})


## <span class="org-todo todo _">🔗</span> References {#d95867}

-   [Exceptions in Clojure](https://grishaev.me/en/clj-book-exceptions/)
    -   けっこうな分量だけどClojureの例外の話題を網羅的にいろいろ書いてる.
