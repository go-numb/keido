+++
title = "📝Clojure Syntax"
tags = ["WIKI"]
draft = false
+++

---
up: [📂Clojure Core]({{< relref "20220112142936.md" >}})
refs:

-   [Clojure.org - syntax](https://www.clojure.org/guides/learn/syntax)


## Clojure: フォーム {#clojure-フォーム}

Clojureの構成要素にいろいろ種類がある.
Clojureではとくに **フォーム** という.

いったん整理したい.

-   number
    -   1
-   symbol
    -   Clojureの世界での表現されるものはシンボルといってもいい.
    -   関数: foo, bar
    -   Javaクラス
    -   名前空間 : user/foo
    -   演算子: +, -
    -   etc...
-   string
    -   "hoge"
-   keyword
    -   :hoge
-   character
    -   \h
-   boolean
    -   true/false/nil
-   list
    -   (1 2 3)


## Clojure: リーダマクロ | Reader Macros {#clojure-リーダマクロ-reader-macros}

cf. [📝Clojure Macros]({{< relref "20220302111024.md" >}})


## Clojure: 特殊形式 | Special Forms {#clojure-特殊形式-special-forms}

Clojureの特殊形式は, Clojureの評価戦略に従わず,
コンパイラが直接解釈するSyntax.

つまり開発者がマクロで改変できないし, 逆にいれば,
これらはマクロの素材になる.

refs: [clojure.org - Special Forms](https://clojure.org/reference/special_forms) [🏷Evaluation Strategy]({{< relref "20220305075933.md#evaluation-strategy" >}})


## Clojure: Threading Macros {#clojure-threading-macros}

-   スレッディングマクロ.
-   基本的には **-&gt;** と **-&gt;&gt;** をつかう.
-   入れ子構造の関数呼び出しを逐次処理な呼び出しに変える.

refs:

-   [clojure.org - Threading Macros Guide](https://clojure.org/guides/threading_macros)
-   [スレッドマクロを整理する - 紙箱](https://boxofpapers.hatenablog.com/entry/threading_macros)


### thread-first (-&gt;) と thread-last (-&gt;&gt;) {#thread-first-----と-thread-last}

-&gt; も -&gt;&gt;も1つ目のフォームを初期値にして2つ目のフォームから逐次適用していく.

-&gt;はフォームの第一引数に引数が入る. 一方, -&gt;&gt;は最終引数に引数が入る.

-&gt;&gt; 利用するケースは第一引数に高階関数を受取り末尾にリストを受け取るような関数である.(map, filter, reduce...)


### tips: clojure thread-firstとthead-lastを混在させる {#tips-clojure-thread-firstとthead-lastを混在させる}

thread-as or as-&gt;をつかうことで, 混在させられる.


### Emacs clojure-mode: M-x clojure-thread {#emacs-clojure-mode-m-x-clojure-thread}

Emacs clojure-modeの threadingリファクタリングサポート.

ref: <https://github.com/clojure-emacs/clojure-mode/#refactoring-support>

-   clojure-unwind: threading expressionを解く.
-   clojure-thread-first-all: -&gt; へ変換.
-   clojure-thread-last-all: -&gt;&gt; へ変換.

threading macrosを理解するには,
-&gt;&gt; の内側で M-x clojure-unwind-allを叩くとスレッディングマクロを使わない場合に変換される. もとに戻すには, M-x clojure-thread-last-all.


### note: Clojure Threading MacrosはR-langのdplyrのpipe記法に似ている {#note-clojure-threading-macrosはr-langのdplyrのpipe記法に似ている}

これは 羽鳥教のdplyrに似てないか？

ref:

-   [羽鳥教のすゝめ ～dplyr編～ | kitayama lab](https://kitayamalab.wordpress.com/2016/05/16/%E7%BE%BD%E9%B3%A5%E6%95%99%E3%81%AE%E3%81%99%E3%82%9D%E3%82%81-%EF%BD%9Edplyr%E7%B7%A8%EF%BD%9E/)
-   [羽鳥教入信のすゝめ - Qiita](https://qiita.com/uri/items/a66b682507181baa0d50)

そしてこの記法の強力な魅力がデータ分析においてR言語をPythonよりも好む人がいるように, Clojureにおいても大変魅力的に違いない.


### memo: threadingとはわたしである {#memo-threadingとはわたしである}

theading = 糸, 筋道. これはつまり, わたしではないか？

ref: [🎓経道とはThreadである]({{< relref "20220209051354.md" >}})


## Clojure: MetaData {#clojure-metadata}

ClojureのSymbolやCollectionには,
MetaDataと呼ばれるデータをmapとして付与して参照することができる.

MetaDataの リーダマクロは **^** みたいなhat表記.

setterとしては, (def ^{:hoge 1} x) のように, defを利用する.

さらに, (def ^:huga y) のように書かれることも多いが,
これは (def ^{:huga true} y)と同じ意味.
mapの表記が省略されて keywordのみが現れている.

MetaDataの一覧を表示するときは, **meta** マクロを利用する.

```clojure
user> (meta #'x)
;; =>
{:line 12,
 :column 7,
 :file "*cider-repl repo/kotori-clj:localhost:38291(clj)*",
 :name x,
 :ns #namespace[user]}
```

refs:

-   [clojure.org - Metadata](https://clojure.org/reference/metadata)
-   [clojure.org - The Reader - Metadata(^)](https://clojure.org/reference/reader#_metadata)


## Active Recalls {#active-recalls}


### Clojure の グローバル変数への束縛とローカル変数の束縛をするシンタックスはそれぞれなんですか? {#clojure-の-グローバル変数への束縛とローカル変数の束縛をするシンタックスはそれぞれなんですか}

それぞれ，def, let.


### Clojure Threading Macrosにおいて -&gt;と-&gt;&gt;の違いはなんですか? {#clojure-threading-macrosにおいて-と-の違いはなんですか}

-&gt;は第一引数に引数が入る，-&gt;&gt;は最終位置似引数がはいる.


### Clojureの特殊形式とはなんですか？また具体例はなんですか？ {#clojureの特殊形式とはなんですか-また具体例はなんですか}

Clojureのコンパイラが独自に解釈するルール.

Spetial Formsともいう. def, if, let, fnなど.
