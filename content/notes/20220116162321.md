+++
title = "📝Clojure Syntax"
lastmod = 2022-08-15T10:47:47+09:00
tags = ["WIKI"]
draft = false
+++

-   up: [📂Clojure Core]({{< relref "20220112142936.md" >}})
-   refs:
    -   [clojure.org - syntax](https://www.clojure.org/guides/learn/syntax)

Clojure言語におけるシンタックスを扱う.

フォームは [📝Clojure フォーム]({{< relref "20220505210059.md" >}}) を参照.


## Clojure: リーダマクロ | Reader Macros {#29c96e8e-02b0-4883-a59e-b08b4b6a70fb}

cf. [📝Clojure Macros]({{< relref "20220302111024.md" >}})


## Clojure: Threading Macros {#508f51c6-37cb-4b61-9bce-91075f1f067e}

-   スレッディングマクロ.
-   基本的には **->** と **->>** をつかう.
-   入れ子構造の関数呼び出しを逐次処理な呼び出しに変える.

refs:

-   [clojure.org - Threading Macros Guide](https://clojure.org/guides/threading_macros)
-   [スレッドマクロを整理する - 紙箱](https://boxofpapers.hatenablog.com/entry/threading_macros)


### thread-first (->) と thread-last (->>) {#8df000}

-> も ->>も1つ目のフォームを初期値にして2つ目のフォームから逐次適用していく.

->はフォームの第一引数に引数が入る. 一方, ->>は最終引数に引数が入る.

->> 利用するケースは第一引数に高階関数を受取り末尾にリストを受け取るような関数である.(map, filter, reduce...)

see also: [💡Clojureデータ構造の操作関数の分類]({{< relref "20220116080205.md#582983e0-0ed8-419e-aa14-c9b227ad42f9" >}})


### as-> clojure thread-firstとthead-lastを混在させる {#f8bc06}

thread-as or as->をつかうことで, 混在させられる.

```clojure
(-> [10 11]
    (conj 12)
    (as-> xs (map - xs [3 2 1]))
    (reverse))
; (11 9 7)
```


### cond-> 条件つきスレッドマクロ {#edc8041c-a7eb-4b51-8433-f8b1038b3ffc}

cond->は初期値と(条件, 処理)のリストを受ける. 条件が真のときのみ処理はされる.

```clojure
(cond-> (初期値)
  (条件) (処理)
  (条件) (処理)
  (条件) (処理))
```

もし存在すれば(if-exists)そのデータを初期値に加えるようなときにつかう. 初期値がcollectionで, もしparamが存在すればそれをcollectionにaddやassocやconjみたいなケースでよく見かける.

[条件付きMap操作: assoc-if/update-if 追加する値がnilでなければ操作]({{< relref "20220302101805.md#659c997d-8c8e-4837-a8b3-a60cc77082c4" >}})


### some->/some->> : 副作用のある呼び出しを中断 {#83a26d9b-05ee-4e0f-b052-49f701755297}

ref. [some-> - Threading Macros Guide](https://clojure.org/guides/threading_macros#_some_some_and_cond)

Threadingマクロの途中で副作用のあるJavaの関数(往々にして戻り値がない, つまりnullを返す可能性がある)を呼び出す時, 途中結果がnullならばその後の処理を打ち切る用途としてsome->というスレッディングマクロがある.


### Emacs clojure-mode: M-x clojure-thread {#f4cff6}

Emacs clojure-modeの threadingリファクタリングサポート.

ref: <https://github.com/clojure-emacs/clojure-mode/#refactoring-support>

-   clojure-unwind/clojure-unwind-all:
    -   threading expressionを解く.
-   clojure-thread-first-all: -> へ変換.
-   clojure-thread-last-all: ->> へ変換.

threading macrosを理解するには,
->> の内側で M-x clojure-unwind-allを叩くとスレッディングマクロを使わない場合に変換される. もとに戻すには, M-x clojure-thread-last-all.


### 💡memo: Clojure Threading MacrosはR-langのdplyrのpipe記法に似ている {#86f044}

これは 羽鳥教のdplyrに似てないか？

ref:

-   [羽鳥教のすゝめ ～dplyr編～ | kitayama lab](https://kitayamalab.wordpress.com/2016/05/16/%E7%BE%BD%E9%B3%A5%E6%95%99%E3%81%AE%E3%81%99%E3%82%9D%E3%82%81-%EF%BD%9Edplyr%E7%B7%A8%EF%BD%9E/)
-   [羽鳥教入信のすゝめ - Qiita](https://qiita.com/uri/items/a66b682507181baa0d50)

そしてこの記法の強力な魅力がデータ分析においてR言語をPythonよりも好む人がいるように, Clojureにおいても大変魅力的に違いない.


### 💡memo: threadingとはわたしである {#7e644b}

theading = 糸, 筋道. これはつまり, わたしではないか？

ref: [🎓経道とはThreadである]({{< relref "20220209051354.md" >}})


## Clojure: MetaData {#ca093748-03c2-44ce-bc6d-ab1e4c158255}

ClojureのSymbolやCollectionには, MetaDataと呼ばれるデータをmapとして付与して参照することができる.

MetaDataの リーダマクロは **^** みたいなhat表記.

setterとしては, (def ^{:hoge 1} x) のように, defを利用する.

さらに, (def ^:huga y) のように書かれることも多いが, これは (def ^{:huga true} y)と同じ意味. mapの表記が省略されて keywordのみが現れている.

MetaDataの一覧を表示するときは, **meta** マクロを利用する.

```clojure
user> (meta #'x)
;; =>
{:line 12,
 :column 7,
 :file "*cider-repl repo/kotori-clj:localhost:38291(clj)*",
 :name x,
 :ns #namespace[user]}
```

refs:

-   [clojure.org - Metadata](https://clojure.org/reference/metadata)
-   [clojure.org - The Reader - Metadata(^)](https://clojure.org/reference/reader#_metadata)


## Active Recalls {#b27a23}


### Clojure Threading Macrosにおいて ->と->>の違いはなんですか? {#2e5ed3}

->は第一引数に引数が入る，->>は最終位置似引数がはいる.


### ClojureのMetaDataのリーダマクロはなんですか？ {#9cd56c}

^
