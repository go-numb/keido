+++
title = "📝並行プログラミング"
lastmod = 2022-10-08T16:45:40+09:00
tags = ["WIKI", "TAG"]
draft = false
+++

-   up: [📂プログラミングパラダイム]({{< relref "20220116193313.md" >}})

このメモでは並行/並列あわせてConcurrentいう性質のプログラミングパターンを扱う.

[💡並行計算と並列計算の違い](#5002c7e0-1d37-4cba-8140-a8cbce533ade)


## 並行プログラミング(Concurrenct Programming) {#252e0c}

Concurrent Programming, 並行プログラミング.

複数の相互作用を及ぼす計算タスクの (同時) 並行的実行をおこなうパラダイム.

-   [並行計算 - Wikipedia](http://ja.wikipedia.org/wiki/%E4%B8%A6%E8%A1%8C%E8%A8%88%E7%AE%97)

> Multiple progressing activities that exist at the same time
> Activities that can communicate and synchronize
>
> -   Communicate: information passes from one activity to another
> -   Synchronize: an activity waits for another to perform a specific action.

並行プログラミングには 3 つの代表的なパラダイムがある.

-   [📝共有メモリモデル(Shared-State Concurrency)]({{< relref "20220717163756.md" >}})
-   Message-passing concurrency (Erlang and Scala actor)
-   Detarministic Dataflow

その他, 並列実行の競合をさけるためには, 以下ようなパラダイムもある.

-   Lazy Deterministic Dataflow
-   Constraint Programming


## 並列プログラミング(Parallel Programming) {#2aa4744e-9f27-4e26-ad9c-87941b13185e}

Parallel Computing(並列計算)とは, コンピュータにおいて特定の処理をいくつかの独立した小さな処理に細分化し、複数の処理装置（プロセッサ）上でそれぞれの処理を同時に実行させること.

そしてそれを実行するためのプログラミング手法が並列プログラミング.

しばしば, [📝並行プログラミング]({{< relref "20220116195030.md" >}})と混同される. 並列計算はマルチプロセッサ(2コア以上)が前提となる. 独立した各プロセッサが割り振られた計算を同時実行する.

-   links
    -   [並列計算 - Wikipedia](http://ja.wikipedia.org/wiki/%E4%B8%A6%E5%88%97%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%83%86%E3%82%A3%E3%83%B3%E3%82%B0)


## 共有メモリモデル {#f54244}

メモ分割. [📝共有メモリモデル]({{< relref "20220717163756.md" >}})


## Message-passing concurrency: メッセージ伝達モデル {#528390}

Scala や Erlang で採用されている方法.


## 📝決定性データフローモデル - Detarministic Dataflow {#36836d27-a839-4ea9-ad92-211f95426397}

決定性データフロープログラミング. 関数型パラダイムをべースにしている.

ref. [データフロープログラミング - Wikipedia](http://ja.wikipedia.org/wiki/%E3%83%87%E3%83%BC%E3%82%BF%E3%83%95%E3%83%AD%E3%83%BC%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0)

スレッド処理, 時間経過をともなうのにも関わらず, 実行結果はつねに一定! これが, Deterministic と名づけられた所以.

Deerministic is not Obsarbable.

アイデア自体は 70 年代に提示されたアイデアのに, 今まで忘れ去れれていた.

-   MultiCore, ManyCore Processing (マルチコア, メニーコア)
-   Destributed Computing
-   Concurrent Deployment
-   BigData Computing

以上のようなキーワードとともに, 21 世紀の今こそ注目をあびるべき, 次世代プログラミングパラダイム!(とピーターバンロイさんがいっていた)

CTMCP, Chapter 4

-   関数型プログラミングを一般化した. 関数型に並行性を加えたもの.
-   並行性は透過. 途中でスレッドをいくら追加しても, 削除しても, 待たせても, 実行順序によって結果が変わらない!


### Unbound Value {#577f89}

メモリ上に値が存在しないが, 宣言された変数.

-   C/C++ では, ゴミ (不定データ) が格納されている.
-   Java は 0 初期化されている.
-   Prolog は実行時にエラー終了する.
-   Oz は値が bind されるまでまちあわせる.


### DataFlow Value {#1f04b4}

Unbound Value が bind されるまでプログラムの実行を待ち合わせるような宣言的変数.

Bind されたときの実行を Dataflow Execution という.

あるスレッドがデータフロー変数を利用しようとしたとき, その変数に値が束縛されていない場合は, 別のスレッドが束縛するまで待ち合わせを行う.

このデータフロー変数によって, No Race Conditions (非強豪状態) を実現する!(これがもっともこのパラダイムで大事)

[競合状態 - Wikipedia](http://ja.wikipedia.org/wiki/%E7%AB%B6%E5%90%88%E7%8A%B6%E6%85%8B)


### Threads {#03bfae}

プログラムの処理の単位 (Thread of Program)

-   Each thread is sequential.
-   Each thread is independent of the others.
    -   Two threads can communicate if they share a variable

Wikipedia では CPU のひとつの処理単位と定義されている.


### Streams {#21b3cb}

リストの終端が Unbound Variable であるもの. Streams は 2 つの Thread 間の通信チャネルとして利用できる.

すべての List 関数は Agent になりえる,すべての関数型言語のテクニックは決定性データフローに応用できる.


### Producer-Consumer Pattern {#1e0ae462-5cdf-45d2-82de-ef3587583ff1}

並行プログラミングパラダイムの頻出パターン.

-   Producer: ストリームのデータを生成.
-   Consumer: Producer から生成されたストリームのデータを受け取ってアクションを起こす

[共有メモリモデル]({{< relref "20220717163756.md" >}})で排他制御をする場合, blockingqueueを利用して２つのスレッドでread/writeするような実装となる.

---

むかし実装の勉強を結構したし, その後もRubyやPythonでスレッド処理を実装するならばよくでてくる王道パターンかつ思い出深いトピック.

-   [データフロー変数 (Oz) で実現する Producer-Consumer Pattern | Futurismo](https://futurismo.biz/archives/2829/)
-   [Java で Producer-Consumer Pattern を実装してみた | Futurismo](https://futurismo.biz/archives/2656/)
-   [共有メモリでの排他制御はProducer-consumer pattern]({{< relref "20220717145220.md#336a827e-3af1-4425-8844-74b1e21b7792" >}})


### Pipeline Pattern {#6e0433}

-   Transformer
    -   Producer と Consumer との間を仲介する
-   Pipeline
    -   Producer と Consumer と Transformer の間を仲介する.
    -   [Pipeline (software) - Wikipedia, the free encyclopedia](http://en.wikipedia.org/wiki/Pipeline_(software))
    -   [パイプライン処理 - Wikipedia](http://ja.wikipedia.org/wiki/%E3%83%91%E3%82%A4%E3%83%97%E3%83%A9%E3%82%A4%E3%83%B3%E5%87%A6%E7%90%86)

単一格納変数 (single-assined value) の性質 (一度しか代入できない)を同期のスレッド間通信のための手段にする.


### Agents {#375099}

並行スレッドのなかで Stream を読み書きするものを Agents という.

```language
   S1=1|2|3..              S2=1|4|9..
   Produce ----------> Transformer --------> Consuemer
   S1={Prod 1}          S2={Trans S1}         {Disp S2}
```


### NonDeterminism {#6e2aeb}

非決定性. プログラムの実行結果を決定ことができるシステムの能力.

Nondeterminism は managed されることが必須! しかし, 制御がとても難しい. だからこそ, Determinism が重要なのだと.


#### example {#1a79a4}

X になにが設定されるかは, システムが決める. プログラマが決めることはできない.

```oz
    declare X = {NewCell 0}
    therad X:=1 end
    therad X:=2 end
```


#### Scheduler {#ffaac1}

どのスレッドを実行するかを決める, システムの一部をスケジューラという.


### Concurrency Transparency {#df1664}

並行透過性.

複数のユーザーが 1 つのリソースを共有して使用するとき, それらユーザーに競合状態を気づかせてはならない.

-   [透過性 (情報工学) - Wikipedia](http://ja.wikipedia.org/wiki/%E9%80%8F%E9%81%8E%E6%80%A7_(%E6%83%85%E5%A0%B1%E5%B7%A5%E5%AD%A6))


#### concurrency for dummies {#4fd56a}

並行性のためのダミースレッド.

並行透過性のためには, いくらスレッドを動的に追加しようとも, 削除しようとも, 最終的に得られる結果はかわらない (Deterministic!)

それは, スレッドの各処理を incremental に動作させることで可能となる


#### ForCollect {#eadb8c}

手続き型の for 文と 宣言型の不定性を共存させる for 文.

Cell と higher-order-programming をつなげる概念.

Map や Filter の一般化と言える.

```oz
proc {ForCollect Xs P Ys}
   Acc={NewCell Ys}
   proc {C X} R2 in @Acc=X|R2 Acc:=R2 end
in
   for X in Xs do {P C X} end @Acc=nil
end
```

-   List に適用すれば, リスト内包表記.
-   Stream に適用すれば, 並行エージェント.


#### List Complehention: リスト内包表記 {#15100c}

ForCollect をリストに適用したもの.

python や haskell は言語で実装されている.


## Stream Processing {#2c3012}

並列処理を実現するプログラミング手法の一つ.

-   [ストリーム・プロセッシング - Wikipedia](http://ja.wikipedia.org/wiki/%E3%82%B9%E3%83%88%E3%83%AA%E3%83%BC%E3%83%A0%E3%83%BB%E3%83%97%E3%83%AD%E3%82%BB%E3%83%83%E3%82%B7%E3%83%B3%E3%82%B0)

大規模なデータをリアルタイムに処理したいときに利用する. Batch Processing では, ダメ. 完了まで, 待たなければいけない.

センサー情報をリアルタイムで機械学習で処理するような使い方.


### Apache Storm {#0892e8}

Twitter 社がオープンソースにした分散リアルタイム解析ソフト.

-   <http://www.slideshare.net/AdvancedTechNight/twitterstorm>
-   <http://www.slideshare.net/takanorig/storm-31157560>


## Software transactinal memory(STM) {#2b37f626-bb5f-4c2c-bd7c-802134d9df87}

いわゆるSTM(表記が長いじゃないか...).

ref: 🔗[ソフトウェアトランザクショナルメモリ - Wikipedia](https://ja.wikipedia.org/wiki/%E3%82%BD%E3%83%95%E3%83%88%E3%82%A6%E3%82%A7%E3%82%A2%E3%83%88%E3%83%A9%E3%83%B3%E3%82%B6%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%8A%E3%83%AB%E3%83%A1%E3%83%A2%E3%83%AA)

3つの重要な特性がある.

-   Atomic
    -   複数のメモリを更新しても外部からはひとつのイベントで観測される.
-   Consistent
    -   更新は一貫している.
    -   更新後のvalidationが失敗すれば全ての更新処理は失敗する.
-   Isolated
    -   あるトランザクションから別のトランザクションをみることはできない.


## 💡並行計算と並列計算の違い {#5002c7e0-1d37-4cba-8140-a8cbce533ade}

これについて, 観点によって言葉の使い方が違うように思う, 闇が深い...

大事なことは議論をするならば前提としてお互いの認識を合意してその先の議論をしたいところ. そもそも先の議論をしたいはずで, この場で相手と並行並列の定義の議論をする予定ではなかったはずなので喧嘩せずに合意がとれればいい.

Wikipediaでいうところの定義はハードウェア(計算機)の視点であるが, 私が関心があるのはソフトウェアの視点だったりする.


### 並行計算と並列計算の違いは？ {#908d6081-63c6-4abf-b0b0-3e2a6dd4f01f}

並行（Concurrent）は「複数の動作が, 論理的に, 順不同もしくは同時に起こりうる」こと. ある1つの時点では1つの仕事しかしていないが, 複数の仕事間を切り替えることによって同時にやっているように見えること.

並列（Parallel）は「複数の動作が, 物理的に, 同時に起こること」.

並行は一つのCPUがプロセスを切り替えながら処理を行う. 並列は複数のCPUが複数のプロセスを同時に行う.

---

名前が似ているのでとても忘れやすい....

-   [スレッドとタスクの違いについてしらべてみた(C++/Linux) | Futurismo](https://futurismo.biz/archives/2245/)


### 並行のサブ概念が並列 {#739f423e-55a4-413b-a4f5-1ce8e82a7a82}

以下を自分なりに解釈して要約.

-   [君たちの「並行」の理解は間違ってる](https://zenn.dev/koron/articles/3ddcaaeae37f9befdf70)
-   [たとえばなしで見る誇張の少ない「並行」と「並列」](https://zenn.dev/koron/articles/05210473c8fc62f5e8fb)

並行はConcurrent, ともに(con)走る(cur). 同時にという意味であり, それ以上の意味はない.

そうすると, いわゆる並列でいうところの「複数の処理装置（プロセッサ）上でそれぞれの処理を **同時に** 実行させることである」というのは, Concurretという性質を含んでいる.

すると, 並列という概念は並行のサブ概念となる.

ネットでよく見かける説明, 並行がマルチコア, 並列がマルチスレッドというものも, この定義から考えると間違っている. 並列をシングルコアで動かすこともできるが, それだとオーバーヘッドが増えるだけで性能悪化するだけなので, 並列は複数コアでの動作を前提にしている.


### 並行は独立して実行できる/並列は同時に実行すること {#8a7745}

英語の書籍とかブログをみると, Concurrent Programmingという見出しがついているもの, 実際はスレッドうんぬんの話が展開されているものが多く, ここの点がもやもやしている.

> when people hear the word concurrency they often think of parallelism

この点についConcurrentはParallelismとは違うという話題をGoの視点からみる.

-   [並行処理と並列処理｜Goでの並行処理を徹底解剖！](https://zenn.dev/hsaki/books/golang-concurrency/viewer/term)
-   [Concurrency is not parallelism - The Go Programming Language](https://go.dev/blog/waza-talk)

> Concurrency is about dealing with lots of things at once. Parallelism is about doing lots of things at once..

-   時間軸
    -   ある範囲において複数のタスクを扱う
    -   ある点において複数のタスクを扱う
-   構成 vs 実行
    -   並行は独立に実行出来る構成
    -   並列は同時に実行すること
-   ソフトウェア vs ハードウェア
    -   並行はRace Conditionの解決のためのプログラミングパターン
    -   並列は並行処理を可能にするハードウェアの特性.
    -   並行性はコードの性質 vs 並列は動作しているプログラムの性質


## Concurrent Topics {#b7e834}


### 並行と平行が間違えやすい {#10691bea-9279-4203-a8fa-e3066e30b0cc}

名前が似ているので注意すること. 私は10年くらい間違った漢字を使っていて衝撃を受けたしTwitterで検索しても同じような間違いをしている人はおおい.

-   平行: 二つの直線が交わらない.
-   並行: ならんで進む, 同時に行う.

平行は数学のコンテキストでよくつかう. 並行は計算機科学のコンテキストでよくつかう.

---

さらに紛らわしいのは平行の一般的な英訳はparallelであるが, プログラミングの世界においてparallelとは並列を指す. なんだこれ.


## References {#d95867}

-   [📝Clojure Concurrency]({{< relref "20220116191927.md" >}})


### Books {#6225eb}

Archtecture Patterns のページも参照のこと.

POSA2:  [Pattern-Oriented Software Architecture: Patterns for Concurrent and Networked Objects](http://www.dre.vanderbilt.edu/~schmidt/POSA/POSA2/)

結城先生のマルチスレッドに関する本. 内容は POSA2 の真似.

-   [『増補改訂版 Java 言語で学ぶデザインパターン入門マルチスレッド編』](http://www.hyuki.com/dp/dp2.html)
